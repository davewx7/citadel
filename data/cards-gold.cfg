{
	"King's Rider": {
		name: "King's Rider",
		type: "creature",
		cost: 3,
		loyalty_cost: 2,
		school: "@eval GOLD",
		creature: {
			tags: ['Human', 'Mounted'],
			sprite_sheet: "creature_large",
			image_num: 1,
			attack: 2,
			life: 2,
			move: 3,

			activated_abilities: [
				{
					name: 'Maneuver',
					cost: 1,
					school: "@eval GOLD",
					rules: "Move this creature to an adjacent lane.",
					exhausts_creature: true,

					possible_targets: "
					 def(class game game, class creature creature, [Loc] targets) ->[Loc]|null
						if(targets = [], filter([
								[creature.loc[0]-1, creature.loc[1]],
								[creature.loc[0]+1, creature.loc[1]]],
							game.creature_at_loc(value) = null), null)
					",

					on_play: "def(class game game, class creature creature, class message.play_ability info) ->commands [
						set(creature.loc, info.targets[0])
					] asserting size(info.targets) = 1",
				}
			]
		}
	},

	"Master Fencer": {
		name: "Master Fencer",
		type: "creature",
		cost: 3,
		loyalty_cost: 3,
		school: "@eval GOLD",
		creature: {
			tags: ['Human'],
			overlays: [ { image_num: 25 } ],
			activated_abilities: [
				{
					name: 'First Strike',
					cost: 1,
					school: "@eval GOLD",
					rules: "This creature gains First Strike this turn.",
					on_play: "def(class game game, class creature creature, class message.play_ability info) ->commands
					    creature.add_ability_until_end_of_turn('First Strike')"
				},

				{
					name: "Lunge",
					cost: 1,
					school: "@eval GOLD",
					rules: "This creature gains &+;&1;&attack; this turn.",
					on_play: "def(class game game, class creature creature, class message.play_ability info) ->commands
					    creature.apply_effect_until_end_of_turn('attack', 1)"
				},

				{
					name: "Swift",
					cost: 1,
					school: "@eval GOLD",
					rules: "This creature gets &+;&1;&move; and &-;&1;&life; this turn.",
					on_play: "def(class game game, class creature creature, class message.play_ability info) ->commands
					[
					    creature.apply_effect_until_end_of_turn('move', 1),
					    creature.apply_effect_until_end_of_turn('life', -1),
					]"
				},

			],
			attack: 2,
			life: 2,
			move: 2,
			image_num: 35
		}
	},

	"Dwarvish Warrior": {
		name: "Dwarvish Warrior",
		type: "creature",
		cost: 3,
		loyalty_cost: 1,
		school: "@eval GOLD",
		creature: {
			tags: ['Dwarf'],
			attack: 2,
			life: 2,
			move: 2,
			resistance: 1,
			initiative: 20,
			image_num: 42,

			//carries a sword and shield
			overlays: [ { image_num: 13, }, { image_num: 20, } ],
		}
	},

	"Stalwart Warrior": {
		name: "Stalwart Warrior",
		type: "creature",
		cost: 4,
		loyalty_cost: 0,
		school: "@eval GOLD",
		creature: {
			tags: ['Dwarf'],
			attack: 2,
			life: 2,
			move: 1,
			resistance: 3,
			initiative: 20,
			image_num: 42,

			//carries a sword and shield
			overlays: [ { image_num: 13, }, { image_num: 20, } ],
		}
	},

	"Oldric, Lord of the Hold": {
		name: "Oldric, Lord of the Hold",
		type: "creature",
		cost: 4,
		loyalty_cost: 4,
		school: "@eval GOLD",
		hero: true,
		creature: {
			tags: ['Dwarf', 'Lord'],
			attack: 4,
			life: 4,
			move: 2,
			resistance: 3,
			initiative: 20,
			image_num: 42,

			//carries a sword and shield
			overlays: [ { image_num: 13, }, { image_num: 20, } ],
		}
	},

	"Guard of the Keep": {
		name: "Guard of the Keep",
		type: "creature",
		cost: 2,
		loyalty_cost: 3,
		school: "@eval GOLD",

		rules: "Guard of the Keep may be summoned on any construct you control.",

		possible_targets: "def(class game game, int nplayer, [Loc] targets) ->[Loc]|null
			if(targets = [],
				game.players[nplayer].summoning_locs(game, creature) +
				filter([bldg.loc | bldg <- game.constructs,
								   bldg.controller = nplayer],
				       (not game.creature_at_loc(value)))
			)
			asserting creature
		",
		creature: {
			tags: ['Dwarf'],
			attack: 2,
			life: 2,
			move: 2,
			initiative: 20,
			image_num: 42,

			//carries a sword and shield
			overlays: [ { image_num: 13, }, { image_num: 20, } ],
		}
	},
	
	"Dwarvish Engineer": {
		name: "Dwarvish Engineer",
		type: "creature",
		cost: 3,
		loyalty_cost: 1,
		school: "@eval GOLD",
		rules: "You may summon constructs on or adjacent to Dwarvish Engineer.",
		creature: {
			name: 'Dwarvish Engineer',			
			tags: ['Dwarf'],
			allows_summoning: "def(class game game, class creature target) ->[Loc]
			if(target.is_construct,
			  filter(game.all_locs, (game.locs_adjacent(value, loc) or value = loc) and
			         game.construct_at_loc(value) = null), [])",

			school: "@eval GOLD", 
			attack: 1,
			life: 2,
			move: 2,
			initiative: 20,
			image_num: 71,
		}
	},

	"Barracks": {
		name: "Barracks",
		type: "creature",
		cost: 4,
		loyalty_cost: 2,
		school: "@eval GOLD",
		rules: "You may summon creatures on or adjacent to Barracks.",
		creature: {
			tags: ['Building'],
			is_construct: true,
			allows_summoning: "def(class game game, class creature target) ->[Loc]
			if(not target.is_construct,
			  filter(game.all_locs, (game.locs_adjacent(value, loc) or value = loc) and
			         game.creature_at_loc(value) = null), [])",
		}
	},

	"Launchpad": {
		name: "Launchpad",
		type: "creature",
		cost: 1,
		loyalty_cost: 5,
		school: "@eval GOLD",
		rules: "At the start of each turn, a creature on the same tile as Launchpad gets &+;&2;&move; this turn.",
		creature: {
			tags: ['Building'],
			is_construct: true,
			on_begin_turn: "def(class game game) ->commands
				map(game.creatures, if(value.loc = me.loc, value.apply_effect_until_end_of_turn('move', 2)))
			"
		}
	},

	"Dwarvish Crossbow": {
		name: "Dwarvish Crossbow",
		type: "creature",
		cost: 2,
		loyalty_cost: 2,
		school: "@eval GOLD",
		rules: "When it is not your turn, Dwarvish Crossbow has &0;&attack;.",
		creature: {
			tags: ['Dwarf'],
			attack: 3,
			life: 2,
			move: 2,
			range: 2,
			resistance: 1,
			image_num: 71,
			on_begin_turn: "def(class game game) ->commands
			  if(game.current_player != controller, me.apply_effect_until_end_of_turn('attack', -attack))"
			
		}
	},

	"Ballista": {
		name: "Ballista",
		type: "creature",
		cost: 3,
		loyalty_cost: 3,
		school: "@eval GOLD",
		creature: {
			abilities: ["Fortification"],
			sprite_sheet: 'building',
			life: 2,
			range: 5,
			attack: 1,
			image_num: 0,
		}
	},

	"Guard Post": {
		name: "Guard Post",
		type: "creature",
		cost: 2,
		loyalty_cost: 3,
		school: "@eval GOLD",
		creature: {
			abilities: ["Fortification"],
			resistance: 1,
			life: 4,
			range: 2,
			attack: 2,
			image_num: 0,
			sprite_sheet: 'building',
		}
	},

	"Wall of Stone": {
		name: "Wall of Stone",
		type: "creature",
		cost: 3,
		loyalty_cost: 1,
		school: "@eval GOLD",
		creature: {
			tags: ["Wall"],
			life: 3,
			resistance: 2,
			sprite_sheet: 'building',
			image_num: 0,
		}
	},

	"Market": {
		name: "Market",
		type: "creature",
		cost: 3,
		loyalty_cost: 1,
		school: "@eval GOLD",
		rules: "At the start of your turn, you gain &+;&1;&mana;.",
		creature: {
			tags: ["Marketplace"],
			life: 1,
			is_construct: true,
			image_num: 0,

			on_begin_turn: "def(class game game) ->commands
			if(game.current_player = controller,
			   add(game.players[controller].resources, 1))",
		}
	},

	"Eldric's Bazaar": {
		name: "Eldric's Bazaar",
		type: "creature",
		cost: 1,
		loyalty_cost: 2,
		school: "@eval GOLD",
		rules: "-1 Hand size. At the start of your turn, you gain &+;&2;&mana;.",
		creature: {
			tags: ["Marketplace"],
			life: 1,
			is_construct: true,
			image_num: 0,

			on_begin_turn: "def(class game game) ->commands
			if(game.current_player = controller,
			   add(game.players[controller].resources, 2))",

			static_effect: "def(class game game) -> commands
			if(controller >= 0,
			   game.players[controller].apply_static_effect(
				(def(class player p) ->commands add(p.hand_size, -1)),
				(def(class player p) ->commands add(p.hand_size, 1))
			))",
		}
	},

	"Mine": {
		name: "Mine",
		type: "creature",
		cost: 3,
		loyalty_cost: 2,
		school: "@eval GOLD",
		rules: "At the start of your turn, you gain &+;&1;&mana;.",
		creature: {
			tags: ["Mine"],
			abilities: ["Indestructible"],
			life: 3,
			is_construct: true,
			image_num: 0,

			on_begin_turn: "def(class game game) ->commands
			if(game.current_player = controller,
			   add(game.players[controller].resources, 1))",
		}
	},

	"Stormgard Armory": {
		name: "Stormgard Armory",
		type: "creature",
		cost: 4,
		loyalty_cost: 4,
		school: "@eval GOLD",
		rules: "Creatures you control in this lane have &+;&1;&attack; and &+;&1;&resist;.",
		creature: {
			tags: ["Forge"],
			life: 6,
			is_construct: true,
			image_num: 0,

			static_ability_effect: "if(creature.controller = target.controller and creature.loc[0] = target.loc[0], [target.apply_static_effect('attack', 1), target.apply_static_effect('resistance', 1)])",
		}
	},

	"Dwarf Forge": {
		name: "Dwarf Forge",
		type: "creature",
		cost: 4,
		loyalty_cost: 2,
		school: "@eval GOLD",
		rules: "Creatures you control in this lane have &+;&1;&attack; and &+;&1;&life;.",
		creature: {
			tags: ["Forge"],
			life: 4,
			is_construct: true,
			image_num: 0,

			static_ability_effect: "if(creature.controller = target.controller and creature.loc[0] = target.loc[0], [target.apply_static_effect('attack', 1), target.apply_static_effect('life', 1)])",
		}
	},
	
	"Dwarvish Armourer": {
		name: "Dwarvish Armourer",
		type: "creature",
		cost: 2,
		loyalty_cost: 2,
		school: "@eval GOLD",
		creature: {
			tags: ['Dwarf'],
			attack: 1,
			life: 3,
			move: 2,
			resistance: 1,
			initiative: 20,
			image_num: 71,
		}		
	},

	"Shore Up": {
		name: "Shore Up",
		type: "spell",
		school: "@eval GOLD",
		cost: 2,
		loyalty_cost: 3,
		is_response: true,
		rules: "Target creature with Fortification gains &+;&5;&life;.",
		possible_targets: "def(class game game, int nplayer, [Loc] targets) ->[Loc]|null
		  if(targets = [], [creature.loc | creature <- game.creatures, creature.fortification, creature.summoned, creature.is_valid_target(game, nplayer, me)])",
		on_play: "def(class game game, class message.play_card info) ->commands
		  add(game.creature_at_loc_or_die(info.targets[0]).life, 5)
				  asserting size(info.targets) = 1"
	},
	
	"Armour Up": {
		name: "Armour Up",
		type: "spell",
		school: "@eval GOLD",
		cost: 2,
		loyalty_cost: 1,
		is_response: true,
		rules: "Target creature gains &+;&1;&resist;.",
		possible_targets: "all_creatures_as_possible_targets",
		on_play: "def(class game game, class message.play_card info) ->commands
		  add(creature.resistance, 1)
			asserting size(info.targets) = 1
			where creature = game.creature_at_loc_or_die(info.targets[0])",
	},
	
	"Whites of their Eyes": {
		name: "Whites of their Eyes",
		type: "spell",
		school: "@eval GOLD",
		cost: 2,
		loyalty_cost: 2,
		is_response: true,
		rules: "Ranged creatures you control gain &+;&1;&range;, &+;&2;&attack;, and First Strike this turn.",
		possible_targets: "def(class game game, int nplayer, [Loc] targets) ->[Loc]|null null",
		on_play: "def(class game game, class message.play_card info) ->commands map(game.creatures, creature, if(creature.range > 1 and creature.controller = game.current_player, [
			creature.apply_effect_until_end_of_turn('range', 1-creature.range),
			creature.apply_effect_until_end_of_turn('attack', 2),
			creature.add_ability_until_end_of_turn('First Strike')]))",
	},
	
	"Forced March": {
		name: "Forced March",
		type: "spell",
		school: "@eval GOLD",
		cost: 2,
		loyalty_cost: 2,
		rules: "Creatures you control get &+;&2;&move; and &-;&1;&life; this turn.",
		possible_targets: "def(class game game, int nplayer, [Loc] targets) ->[Loc]|null null",
		on_play: "def(class game game, class message.play_card info) ->commands
			[ [creature.apply_effect_until_end_of_turn('life', -1),
			   creature.apply_effect_until_end_of_turn('move', 2) ] |
			 creature <- game.creatures,
			 creature.controller = game.current_player_index,
			 not creature.fortification]"
	},
	
	"Blessing of Glothorn": {
		name: "Blessing of Glothorn",
		type: "spell",
		school: "@eval GOLD",
		cost: 0,
		loyalty_cost: 3,
		rules: "All Dwarves gain the ability 'Glothorn\'s Blessing: This creature gets &+;&2;&attack; and &-;&1;&resist; this turn.'",
		on_play: "def(class game game, class message.play_card info) ->commands map(game.creatures,
			if('Dwarf' in creature.tags and find(creature.activated_abilities, value.name = q(Glothorn's Blessing)) != null, 
			add(creature.activated_abilities, [{
				name: q(Glothorn's Blessing),
				cost: 1,
				school: GOLD,
				rules: 'This creature gets &+;&2;&attack; and &-;&1;&resist; this turn.',
				on_play: q(def(class game game, class creature creature, class message.play_ability info) ->commands [
					creature.apply_effect_until_end_of_turn('attack', 1),
					creature.apply_effect_until_end_of_turn('resistance', -1)
				])
			}])) where creature = class creature :: value)",		
	},

	"Rune Cannon": {
		name: "Rune Cannon",
		type: "creature",
		school: "@eval GOLD",
		cost: 3,
		loyalty_cost: 3,
		rules: "At the end of your turn, Rune Cannon gains &+;&1;&energy; if it has &0;&exhaust;.",
		creature: {
			tags: ["Cannon"],
			is_construct: true,
			image_num: 7,
			attack: 0,
			life: 2,


			on_end_turn: "def(class game game) ->commands
			if(game.current_player_index = controller and not is_exhausted,
				add(me.energy, 1)
			)",

			activated_abilities: [{
				name: 'Fire',
				cost: 0,
				school: "@eval GOLD",
				loyalty_cost: 1,
				rules: "Remove all &energy; from this creature, and target creature or building gets that many wounds.",
				possible_targets: "
				def(class game game, class creature creature, [Loc] targets) ->[Loc]|null
				  if(targets = [], map(game.creatures, value.loc), null)",
				on_play: "def(class game game, class creature creature, class message.play_ability info) ->commands [
					add(game.creature_at_loc_or_die(info.targets[0]).wounds, creature.energy),
					set(creature.energy, 0),
				]",
			}]
		}
	},
	
	
	"Armed to the Teeth": {
		name: "Armed to the Teeth",
		type: "spell",
		school: "@eval GOLD",
		cost: 4,
		loyalty_cost: 2,
		rules: "Creatures you control gain &+;&1;&attack;, &+;&1;&resist;, and &+;&1;&life;.",
		on_play: "def(class game game, class message.play_card info) ->commands map(game.creatures, creature, if(game.current_player_index = creature.controller and not creature.is_construct, [
			add(creature.resistance, 1),
			add(creature.life, 1),
			add(creature.attack, 1)
		]))",

		runes: [
		{
			color: 'black',
			points: [[0,100], [0,0], [0,0], [100,100]]
		}
		],
	},

	"Tactical Maneuver": {
		name: "Tactical Maneuver",
		type: "spell",
		school: "@eval GOLD",
		cost: 2,
		loyalty_cost: 2,
		rules: "Move target friendly creature to vacant adjacent tile",
		possible_targets: "def(class game game, int nplayer, [Loc] targets) ->[Loc]|null
			switch(size(targets),
			  0, my_creatures_as_possible_targets(game, nplayer, targets),
			  1, if(creature, filter(game.all_locs, game.locs_adjacent(value, creature.loc) and game.creature_at_loc(value) = null), []) where creature = game.creature_at_loc(targets[0]),
			  null)

		",

		on_play: "def(class game game, class message.play_card info) ->commands
		  set(game.creature_at_loc_or_die(info.targets[0]).loc, info.targets[1])",
	},

	"Training Dummy": {
		name: "Training Dummy",
		type: "creature",
		cost: 1,
		loyalty_cost: 2,
		school: "@eval GOLD",
		rules: "When Training Dummy is summoned, you get &+;&2;&gold; exp.",
		creature: {
			tags: ['Mechanical'],
			image_num: 77,
			overlays: [ { image_num: 2 }, { image_num: 8 } ],
			attack: 0,
			range: 0,
			life: 1,
			move: 0,
			on_summoned: "def(class game game) ->commands [
				game.players[controller].level_up(GOLD),
				game.players[controller].level_up(GOLD)
			]"
		}
	},
	
	"Trebuchet": {
		name: "Trebuchet",
		type: "creature",
		cost: 3,
		loyalty_cost: 3,
		school: "@eval GOLD",
		creature: {
			tags: ['Mechanical'],
			image_num: 78,
			attack: 3,
			range: 3,
			life: 3,
			move: 1,
		}
	},

	"Need More Lumber": {
		name: "Need More Lumber",
		type: "spell",
		cost: 0,
		school: 1,
		initiative: 40,
		rules: "Sacrifice a creature you control, you gain &+;&2;&mana;.",

		possible_targets: "def(class game game, int nplayer, [Loc] targets) ->[Loc]|null
			if(targets = [], [creature.loc | creature <- game.creatures, creature.controller = game.current_player])
		",
		on_play: "def(class game game, class message.play_card info) ->commands
		 if(game.current_player = creature.controller,[
		     set(creature.destroyed, true),
			 bind_command(fn, game.players[creature.controller]) where fn = def(class player p) add(p.resources, 2)

		]) where creature = game.creature_at_loc_or_die(info.targets[0])",
	},
}
