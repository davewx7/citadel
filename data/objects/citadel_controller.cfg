{
id: "citadel_controller",
next_animation: "'normal'",
is_human: true,
is_strict: true,
always_active: true,
hidden_in_game: true,
vars: {
	client: null,
	state: null,
	state_id: -1,
	processed_state_id: -1,
	card_preview: null,
	card_preview_for: null,
	game_created: false,
	session_id: -1,
	font: 'RobotoCondensed-Regular',
	color: 'antique_white',
},

tmp: {
	prev_ctrl_keys: [],

	playing_card: -1,
	targets_chosen: [],
	active_targets: [],
	animation_move_time: 0,
	animation_end_time: -1,
	game_state_queue: [],
	furthest_animation_hint: 0,
	animation_hints_id: 0,
	animated_spell_card: null,
	spells_on_stack: [],
	spell_animation_time: 0,

	choice_object: null,

	deck_obj: null,
	discard_obj: null,
	hand_obj: null,
	level_obj: null,

	card_mouseover: null,
	cards_suggest_discard: null,	

	last_state_message: null,

	status_label: null,

	response_pause_counter: -1,

	timer_bar: null,

	turn_schedule: null,
},

properties: {
	game_created: { get: "vars.game_created", set: "set(vars.game_created, value)" },
	session_id: { get: "vars.session_id", set: "set(vars.session_id, value)" },

	level_width: "level.dimensions[2]",
	level_height: "level.dimensions[3]",

	set_status_label: "def(text, color='white', duration=150) [
		if(tmp.status_label, remove_object(tmp.status_label)),
		spawn('citadel_controller.status_label', 0, 0, 1, [
			set(tmp.status_label, child),
			set(child.zorder, 1200),
			if(duration > 0, execute(child, schedule(duration,
			                                         remove_object(child)))),
			debug('init label: ' + text),
			child.init_label(text, color),
		])
	]",

	//adapt our input state to a new game state. For now just clear the
	//input state completely. TODO: adapt it more nicely.
	adapt_input_state: "def(new_state=null) execute(me, [
		if(tmp.card_mouseover, mouse_leave_card(tmp.card_mouseover)),
	   	map(level.chars, if(value.type = 'tile', set(value.selectable, false))),
		set(tmp.playing_card, -1),
		set(tmp.targets_chosen, []),
		set(tmp.active_targets, []),
		set(tmp.cards_suggest_discard, null),
		set(tmp.card_mouseover, null),
	])",

	//debug function to execute FFL on the server.
	server_exec: "def(code) tbs_send(vars.client, {
		type: 'moves',
		state_id: vars.state_id,
		moves: [{
			type: 'debug',
			exe: code
		}]
	})
	",

	debug_draw: "def(ncards) if(is_string(ncards), debug_card(ncards), server_exec('players[current_player].draw_cards(me, ' + ncards + ')'))",
	debug_mana: "def(nmana) server_exec('add(players[current_player].resources, ' + nmana + ')')",
	debug_card: "def(name) server_exec('add(players[current_player].hand, [construct(q(card), get_document(q(data/cards.cfg))[q(' + name + ')])])')",
	
	animation_up_to_date: "vars.processed_state_id = vars.state_id",
	reserve_animation_time: "def(ncycles) if(end_time > tmp.animation_end_time, set(me.tmp.animation_end_time, end_time)) where end_time = level.cycle + ncycles",
	myplayer: "vars.state.players[vars.state.nplayer]",

	hand_index_after_discarding: "def(nhand) nhand - count(level.chars, value.type = 'card' and value.vars.discarded and value.vars.hand_index < nhand)",

	mark_sent_discards: "
	[set(card.vars.sent_discard_msg, true) |
	  card <- level.chars, card.type = 'card', card.vars.discarded = true]
	",

	discard_command: "def(additional_indexes=[])
	if(indexes = [], [], [{type: 'discard', indexes: indexes}])
	  where indexes = additional_indexes + [card.vars.hand_index |
	    card <- level.chars, card.type = 'card', card.vars.discarded = true,
		                     card.vars.sent_discard_msg = false]
	",

	remove_preview_card: "def(card) if(vars.card_preview and (vars.card_preview_for = card or card = null), [if(vars.card_preview.vars.creature, vars.card_preview.vars.creature.destroy()), remove_object(vars.card_preview), set(vars.card_preview, null)])",

	mouse_enter_card: "def(card) (if(tmp.playing_card = -1, if(tmp.card_mouseover = card, null,
	  if(tmp.card_mouseover != null, [
			mouse_leave_card(tmp.card_mouseover),
			execute(me, fire_event('generate_mouseover_card', {card: card})),
		],
	  if(card.vars.in_hand, if(discards,
	  [
	    set(tmp.card_mouseover, card),
	    set(tmp.cards_suggest_discard, discards),

		//synthetic clicks to suggest discarding
	  	[card_right_clicked(card) | card <- level.chars, card.type = 'card', card.vars.hand_index in discards]
	  ]) where discards = (local_player.suggest_discards(local_player.calculate_cost(local_player.hand[card.vars.hand_index]), [card.vars.hand_index] + [card.vars.hand_index | card <- level.chars, card.type = 'card', card.vars.discarded])
	    asserting card.vars.hand_index >= 0 and card.vars.hand_index < size(local_player.hand) |
		  [size(card.vars.hand_index), card.vars.hand_index, card.card_type.name, [[card.vars.hand_index, card.vars.in_hand, card.card_type.name] | card <- level.chars, card.type = 'card'], [card.name | card <- local_player.hand]]))
	  )))

	asserting (not card.vars.in_hand) or (card.vars.hand_index < size(local_player.hand)) | 
	[size(card.vars.hand_index), card.vars.hand_index, card.card_type.name, [[card.vars.hand_index, card.vars.in_hand, card.card_type.name] | card <- level.chars, card.type = 'card'], [card.name | card <- local_player.hand]]
	  )
	  where local_player = myplayer",

	mouse_leave_card: "def(card) if(tmp.card_mouseover = card, [
		map(tmp.cards_suggest_discard, if(obj and obj.vars.discarded, card_clicked(obj)) where obj = find(level.chars, value.type = 'card' and value.vars.hand_index = context.value)),
		set(tmp.card_mouseover, null),
	])",

	//mouse_leave_card: "def(card) execute(me, [remove_preview_card(card)])",
	
	mouse_enter_tile: "def(tile) if(creature, if(card,
	   [
//	     mouse_enter_card({card_type: construct('card', card)}),
		 set(vars.card_preview_for, tile.vars.loc)
	   ]) where card = get_document('data/cards.cfg')[creature.name])
	      where creature = vars.state.creature_at_loc(tile.vars.loc)",
	mouse_leave_tile: "def(tile) remove_preview_card(tile.vars.loc)",

	mouse_enter_log: "def(index)
	   if(items = null, if(is_string(vars.card_preview_for),
			           remove_preview_card(vars.card_preview_for)),
		[
//			 mouse_enter_card({card_type: construct('card',
//			    get_document('data/cards.cfg')[items[1]])}),
			 set(vars.card_preview_for, items[1])
	    ])
	    where items = if(index = -1, null,
		   regex_match(vars.state.log[index], '(.*) plays (.*)'))",

	card_clicked: "def(card) if(vars.state.nplayer = vars.state.current_player,
	  if(card.vars.discarded,
	  [card.set_discarded(false), add(myplayer.resources, -1)],
	  [tile_clicked(null),

	   //commit to any card discard at this point.
	   set(tmp.card_mouseover, null),
	   set(tmp.cards_suggest_discard, null),

	   //choose targets for the card.
	   choose_targets_for_card(card, [])]))",
	card_right_clicked: "def(card) if(vars.state.nplayer = vars.state.current_player,
	 if((not card.vars.discarded) and (not card.card_type.hero), [
	   tile_clicked(null),
	   add(myplayer.resources, 1),
	   card.set_discarded(true)
	],
	 if(card.card_type.hero, set_status_label('Hero cards may not be discarded for mana', 'red'))
	))",

	option_clicked: "def(choice_value) execute(me, [
	debug('option clicked: ' + choice_value),
	tbs_send(vars.client, {
		type: 'moves',
		state_id: vars.processed_state_id,
		moves: [{
			type: 'make_choice',
			choice: choice_value,
		}],
	})
	])",
	      
	tile_clicked: "def(tile) if(not vars.state.current_choice, [
		debug('tile clicked: ' + tile.vars.loc),
	   execute(me, 	map(level.chars, if(value.type = 'tile', set(value.selectable, false)))),
	   if(tile and tmp.playing_card != -1 and tile.selectable, choose_targets_for_card(find(level.chars, value.type = 'card' and value.vars.hand_index = tmp.playing_card), tmp.targets_chosen + [tile.vars.loc]),

		//cancel all discards
	   [
		if(tile, [card_clicked(card) | card <- level.chars, card.type = 'card' and card.vars.discarded]),
		if(tile != null, adapt_input_state(null))
	   ])
	 ])",
	
	choose_targets_for_card: "def(card, current_targets) execute(me,
	if(vars.state.in_response_phase and not card.card_type.is_response,
	set_status_label('Can only cast response spells during response phase', 'red'),
	[
	   if(vars.state.nplayer = vars.state.current_player,
	       [debug('targets: ' + possible_targets),
		    if(can_afford and possible_targets != [] and not unique_violation,
		      if(possible_targets = null,
				[
				 tbs_send(vars.client, {
				   type: 'moves',
				   state_id: vars.processed_state_id,
				   moves: discard_command() + [{type: 'play_card', index: hand_index_after_discarding(card.vars.hand_index), targets: current_targets}]
				  }),
				 mark_sent_discards,
				 set(tmp.playing_card, -1)
				],
			    [
				 map(level.chars, if(value.type = 'tile', set(value.selectable, value.vars.loc in possible_targets))),
				 set(tmp.playing_card, card.vars.hand_index),
				 set(tmp.active_targets, []),
				 set(tmp.targets_chosen, current_targets)
				]),
			  [
			   set_status_label(if(possible_targets = [], 'No valid targets',
			        if(not can_afford, 'Not enough mana',
						card.card_type.name + ' is already on the field, you may not play copies of a hero.')), 'red')
			  ])]
		where unique_violation = card.card_type.hero and card.card_type.creature and find(vars.state.creatures, value.name = card.card_type.name and value.controller = vars.state.nplayer)
		where can_afford = myplayer.can_afford(card.card_type.school, card.card_type.cost, card.card_type.loyalty_cost)
		where possible_targets = card.card_type.possible_targets(vars.state, vars.state.nplayer, current_targets))
	 ]))",
	
	
	creature_clicked: "def(creature) execute(me, [
	    if(creature.vars.creature_object.loc != null,
		  [map(filter(level.chars, value.type = 'creature_status'), value.destroy()),
		   spawn('creature_status', 300, 410, 1, [set(child.creature_object, creature.vars.creature_object)])]
		  )
	  ])",
	
	can_use_ability: "def(creature, ability_name)
	 vars.state.nplayer = vars.state.current_player and
	 vars.state.nplayer = creature.controller and
	 ((not vars.state.in_response_phase) or ability.is_response) and
	 ((not ability.exhausts_creature) or (not creature.is_exhausted)) and
	 myplayer.suggest_discards(myplayer.calculate_cost(ability)) != null and creature.summoned and
	 ability.is_usable(vars.state, creature)
	  asserting ability
	  where ability = find(creature.abilities, (not is_string(value)) and value.name = ability_name)",
	 
	
	ability_clicked: "def(creature, ability_name)
	execute(me, [
	if(animation_up_to_date and can_use_ability(creature, ability_name),
	    [
		  tbs_send(vars.client, 
		  {
			type: 'moves',
			state_id: vars.state_id,
		    moves: discard_command(myplayer.suggest_discards(myplayer.calculate_cost(ability))) + [{type: 'play_ability', creature: creature.summon_id, ability: ability_name}],
		  }),
		  mark_sent_discards
		  ]
	) asserting ability
	  where ability = find(creature.abilities, (not is_string(value)) and value.name = ability_name)
	  ])",
	
	animate_draw_cards: "def(ncards)
	  if(size(cards) >= ncards, map(cards,
		 value.animate_draw()
	  ))
	  where cards = sort([card | card <- level.chars, card.type = 'card', card.vars.hand_index != null], a.vars.hand_index > b.vars.hand_index)",
	
	card_on_stack: "def(card)
	   card.vars.stack_id and find(vars.state.stack, value.stack_id = card.vars.stack_id)",

	handle_animation_hint: "def(hint) [
	if(hint.type in ['play_card', 'play_ability'],
	  [
		reserve_animation_time(100),
		set(tmp.spell_animation_time, 0),
		spawn('card', xloc, 150 + 40*size(vars.state.stack), 1,
			   [
			    if(tmp.animated_spell_card, [
		   		    add(tmp.spells_on_stack, [tmp.animated_spell_card]),
					fire_event(me, 'update_spells_on_stack'),
				]),

			    set(tmp.animated_spell_card, child),
		        set(child.vars.in_hand, false),
				set(child.vars.allow_drag, true),
				set(child.vars.stack_id, hint.stack_id),
			    set(child.animation, 'big'),
			    set(child.alpha, 0),
			    set(child.zorder, 1000 + child.vars.stack_id),
				set(draw_primitives, map(hint.targets, if(target_tile, {
					type: 'arrow',
					points: [
					  [xloc + if(target_tile.mid_x < xloc, -40, 40),
					   284 + 40*(index+1)/(size(hint.targets)+1)],
					  [target_tile.mid_x, 
					   284 + 40*(index+1)/(size(hint.targets)+1)],
					  [target_tile.mid_x, target_tile.mid_y]],
				 }) where target_tile = find(level.chars, value.type = 'tile' and value.vars.loc = context.value))),
			    set(child.card_type,
				 if(hint.type = 'play_card',
				    construct('card', get_document('data/cards.cfg')[hint.card_type]),
					hint.ability))
				])
]
	  where xloc = (level_width - 1024)/2 +
	               if(find(hint.targets, value[1] <= 3),
	            if(find(hint.targets, value[1] >= 7), 512, 712),
	  
	           //none on left
			   if(hint.targets, 312, 512))
	),
	if(hint.type = 'fizzle',
		if(fizzling_card, [
			set(fizzling_card.green, 0),
			set(fizzling_card.blue, 0),
		])
		where fizzling_card = find(level.chars, value.type = 'card' and value.vars.stack_id = hint.stack_id)
	)
   ]
",

	set_widgets_for_message: "def(message)
	  if(message.state.nplayer = message.state.current_player, 
	    set_widgets(
		
		if((not message.state.in_response_phase) and (not message.state.done_movement) and find(message.state.creatures, value.controller = message.state.nplayer) != null,
		[ 
		{
			type: 'button',
			id: 'movement_button',
			x: level_width - 524,
			y: level_height - 618,
			padding: [25, 15],
			resolution: 'normal',
			label: {type: 'label', text: 'Movement',  font: vars.font, size: 16, color: vars.color},
			on_click: def() (if(animation_up_to_date, [set_widgets([]),
			             set(tmp.playing_card, -1),
			             set(tmp.active_targets, []),
						 tbs_send(vars.client,
						   {
						     type: 'moves',
							 state_id: vars.state_id,
						     moves: discard_command() + [{type: 'movement'}]
						   }
						  ),
						  mark_sent_discards
						 ])),
		}
		], []) +
	
		[
		{
			type: 'button',
			id: 'end_turn_button',
			x: level_width - 524,
			y: level_height - 568,
			padding: [25, 15],
			resolution: 'normal',
			label: {type: 'label', text: if((not message.state.in_response_phase), 'End Turn', 'End Response'), font: vars.font, size: 16, color: vars.color},
			on_click: def() if(animation_up_to_date, [set_widgets([]),
			             set(tmp.playing_card, -1),
			             set(tmp.active_targets, []),
						 tbs_send(vars.client, {
						  type: 'moves',
						  state_id: vars.state_id,
						  moves: [{type: 'end_turn'}]
						 })
						 ]),
		},
		
		]),
	    set_widgets([{
			type: 'label',
			text: if((not message.state.in_response_phase), 'Enemy Main Phase', 'Enemy Response Phase'),
			id: 'status_label',
			x: level_width - 524,
			y: level_height - 538,
			font: vars.font, 
			size: 16, 
			color: vars.color			
	   }]))",
	
	set_schedule_for_message: "def(message) [
		if(tmp.turn_schedule, remove_object(tmp.turn_schedule)),
		spawn('citadel_controller.turn_schedule',
		      level_width - 360, 480, 0, [
			set(child.state, message.state),
			set(tmp.turn_schedule, child),
		])
	]",

	spawn_tiles: "def(message)
		 if(find(level.chars, value.type = 'tile') = null, 
		   map(range(message.state.rows), map(range(message.state.columns), spawn('tile', 132 + (level_width - 1024)/2 + col*90 + if(row%2 = 1, 45, 0), 104 + row*52, 1, [set(child.vars.loc, [row,col]), set(child.game_state, message.state)]) where col = value) where row = value),
		   [ [set(tile.game_state, message.state)] | tile <- level.chars, tile.type = 'tile']
		  )
	",

	display_player_life: "def(message)
		map(message.state.players, map(range(max(value.life, 0)), spawn('citadel_controller.heart', if(context.index = 0, 62 + (level_width - 1024)/2, level_width - (52 + (level_width - 1024)/2)), 124 + index*40, 1)))",
	
	display_choice: "def(message) [
	  if(tmp.choice_object, [tmp.choice_object.destroy(), set(tmp.choice_object, null)]),
	  if(message.state.current_choice and message.state.current_choice.player_index = message.state.nplayer,
	  	spawn('choice_controller', 0, 0, facing, [
			set(child.game, message.state),
			set(tmp.choice_object, child),
			debug('spawned choice'),
		 ]))
    ]",

	update_log: "def(message)
		find(level.chars, value.type = 'log_controller').set_log(message.state.log, if(vars.state, myplayer, null))",
},

on_generate_mouseover_card: "mouse_enter_card(card)",

on_create: "[console_output_to_screen(false), if(game_created, 
	[set(vars.client, cl), tbs_send(cl, {type: 'start_game'}), debug('game created')]
		where cl = tbs_client(TBS_SERVER_ADDRESS, TBS_SERVER_PORT, session_id),
	set_widgets(
	[{
		type: 'grid',
		columns: 1,
		children: [

			{
				type: 'button',
				padding: [25, 15],
				resolution: 'double',
				label: {type: 'graphical_font_label', text: 'Join Game', font: 'default', size: 1},
				on_click: def() ([set_widgets([]), set(vars.client, cl),
				             tbs_send(cl, {type: 'request_updates', state_id: vars.state_id})]
				         where cl = tbs_client(TBS_SERVER_ADDRESS, TBS_SERVER_PORT, 2))
			},

			{
				type: 'button',
				padding: [25, 15],
				resolution: 'double',
				label: {type: 'graphical_font_label', text: 'Create Game', font: 'default', size: 1},
				on_click: def() ([set_widgets([]), set(vars.client, cl),
				             tbs_send(cl, {type: 'create_game', game_type: 'citadel', users: [{user: 'a', session_id: 1}, {user: 'b', session_id: 2}]})]
				            where cl = tbs_client(TBS_SERVER_ADDRESS, TBS_SERVER_PORT))
			},

			{
				type: 'button',
				padding: [25, 15],
				resolution: 'double',
				label: {type: 'graphical_font_label', text: 'Play vs Bot', font: 'default', size: 1},
				on_click: def() ([set_widgets([]), set(vars.client, cl),
				             tbs_send(cl, {type: 'create_game', game_type: 'citadel', users: [{user: 'a', session_id: 1}, {user: 'b', bot: true, bot_type: 'goblins', session_id: 2}]})]
				            where cl = tbs_client(TBS_SERVER_ADDRESS, TBS_SERVER_PORT))
			},

		]
	},
	]))]
",

on_update_discard_and_deck: "[
	map(tmp.deck_obj, value.set_label(str(size(vars.state.players[index].deck)), vars.font)),
	map(tmp.discard_obj, value.set_label(str(size(vars.state.players[index].discard_pile)), vars.font)),
	map(tmp.hand_obj, value.set_text(['Cards', str(size(vars.state.players[index].hand)), 'Mana', str(vars.state.players[index].resources)], vars.font)),
	map(tmp.level_obj, value.set_widgets([{
		type: 'grid',
		x: 40,
		columns: 2,
		children: fold(map(vars.state.players[index].resource_level, [
			{
				type: 'image',
				image: 'magic-icons.png',
				area: [3+17*(key-1), 3, 18+17*(key-1), 18],
			},

			{
				type: 'label',
				text: str(value),
				font: 'RobotoCondensed-Bold', 
				color: 'white',
				size: 14,
			}
		]), a+b)
	}])),
]",

on_window_resize: "[
	[ [add(card_back.x, delta_w)]
	| card_back <- level.chars,
	  card_back.type = 'citadel_controller.card_back',
	  card_back.tmp.player_index = 1],

	[ [set(card.mid_x, 117 + card_width*card.vars.hand_index),
	   add(card.y, delta_h), fire_event(card, 'update_pos')]
	| card <- level.chars,
	  card.type = 'card', card.vars.in_hand],
	
	[ tile.destroy() | tile <- level.chars, tile.type = 'tile' ],

    [remove_object(heart) | heart <- level.chars, heart.type = 'citadel_controller.heart'],
	
	set(level.dimensions, [0,0,new_width,new_height]),
	fire_event('dimensions_updated')
] where delta_w = new_width - level_width
  where delta_h = new_height - level_height
  where card_width = min(135, if(hand_size, card_area/hand_size, 100))
  where card_area = new_width - 300
  where new_width = max(width,1024)-1
  where new_height = max(height,768)-1
  where hand_size = count(level.chars, value.type = 'card' and value.vars.in_hand)",

on_dimensions_updated: "[
	if(tmp.last_state_message, [
        display_choice(tmp.last_state_message),
		set_widgets_for_message(tmp.last_state_message),
		set_schedule_for_message(tmp.last_state_message),
		spawn_tiles(tmp.last_state_message),
		adapt_input_state(tmp.last_state_message),
		display_player_life(tmp.last_state_message),
		update_log(tmp.last_state_message),
	]),

	[ [creature.destroy(),
	   spawn('creature', 0, 0, 1,
	          [set(child.creature_object, creature.creature_object)])]
	| creature <- level.chars,
	  creature.type = 'creature',
	  creature.creature_object.loc != null ]
]",

on_update_spells_on_stack: "
 [
  set(tmp.spells_on_stack, survivors),
  map(leaving, execute(value, [
  	set(value.vars.do_not_remove, true),
	[schedule(n, [set(value.alpha, 255-n*10),
	  if(value.vars.creature, set(value.vars.creature.alpha, 255-n*10)),
	  map(value.draw_primitives, set(value.color, [255,0,0,255-n*10]))])
	  | n <- range(25)],
	schedule(26, remove_object(value)),
  ]))
 ]
  where leaving = filter(tmp.spells_on_stack, not card_on_stack(value))
  where survivors = filter(tmp.spells_on_stack, card_on_stack(value))",

on_update_game: "
   if((not force_process) and
      (tmp.game_state_queue != [] or level.cycle < tmp.animation_end_time),
	 add(tmp.game_state_queue, [message]),

	 [
	 	adapt_input_state(message.state),

		if(not tmp.deck_obj, [
			set(tmp.deck_obj, deck_obj),
			set(tmp.discard_obj, discard_obj),
			set(tmp.hand_obj, hand_obj),
			set(tmp.level_obj, level_obj),
			map(discard_obj, set(value.tmp.player_index, index)),
			map(deck_obj, set(value.tmp.player_index, index)),
			map(hand_obj, set(value.tmp.player_index, index)),
			map(level_obj, set(value.tmp.player_index, index)),
			map(discard_obj, set(value.animation, 'front')),
			map(hand_obj, set(value.animation, 'hand')),
			map(level_obj, set(value.animation, 'hand')),
			map(deck_obj, set(value.scale, 0.5)),
			map(discard_obj, set(value.scale, 0.5)),
			map(hand_obj, set(value.scale, 0.5)),
			map(level_obj, set(value.scale, 0.5)),
			map(deck_obj, add_object(value)),
			map(discard_obj, add_object(value)),
			map(hand_obj, add_object(value)),
			map(level_obj, add_object(value)),
		] where deck_obj = map(range(size(message.state.players)), object('citadel_controller.card_back', if(index = 0, 50, level_width - 50), 450, 1))
		  where discard_obj = map(range(size(message.state.players)), object('citadel_controller.card_back', if(index = 0, 150, level_width - 150), 450, 1))
		  where hand_obj = map(range(size(message.state.players)), object('citadel_controller.card_back', if(index = 0, 250, level_width - 250), 450, 1))
		  where level_obj = map(range(size(message.state.players)), object('citadel_controller.card_back', if(index = 0, 50, level_width - 50), 350, 1))),

	 	reserve_animation_time(10),
	    set(vars.processed_state_id, message.state_id),
		map(animation_hints, handle_animation_hint(value)),
		set(tmp.animation_hints_id, message.state.animation_hints_id),
		set(tmp.furthest_animation_hint, size(message.state.animation_hints)),
	    set(vars.state, message.state),
		debug('SET NEW STATE'),

	    debug('got state_id: ' + message.state_id + '/' + vars.state_id + ' response phase: ' + vars.state.in_response_phase),
	    [remove_object(heart) | heart <- level.chars, heart.type = 'citadel_controller.heart'],

		display_player_life(message),
		display_choice(message),
	    if(creature_status,
			if(creature, set(creature_status.creature_object, creature), creature_status.destroy())
			   where creature = find(message.state.creatures,
			        value.summon_id = creature_status.creature_object.summon_id)
				
				) where creature_status = find(level.chars, value.type = 'creature_status'),
	    [map(filter(level.chars, (value.type in ['card', 'tile.level_label']) and ((value.type != 'card') or (not value.vars.do_not_remove) and value != tmp.animated_spell_card) and not (value in tmp.spells_on_stack)), remove_object(value)),

		fire_event(me, 'update_spells_on_stack'),

		spawn_tiles(message)
	  ],

	  if(message.state.in_response_phase and message.state.nplayer = message.state.current_player,
		[
		  spawn('citadel_controller.timer_bar', 0, 0, 1, [
		  	child.create_bar(),
			set(tmp.timer_bar, child),
		  ]),

		  if(tmp.timer_bar, remove_object(tmp.timer_bar)),

	      set(tmp.response_pause_counter, 150),
		  set_status_label(if(message.state.stack, '', 'Combat phase -- ') + 'Press SPACE if you want to respond', 'white', 150),
		],

		[
			if(tmp.timer_bar, remove_object(tmp.timer_bar)),
			set(tmp.response_pause_counter, -1),
		]
	  ),

	  set_widgets_for_message(message),
	  set_schedule_for_message(message),

	  //if we have any creatures that move, we reserve cycles for it to take
	  //place before other animations will proceed
	  set(tmp.animation_move_time, if(find(
	     [ new_obj and new_obj.loc != creature.loc
	    where new_obj = find(message.state.creatures,
		                     value.summon_id = creature.summon_id) or
							 message.state.graveyard[creature.summon_id]
	    where creature = obj.vars.creature_object
		| obj <- level.chars, obj.type = 'creature'],
		value), 30, 0)), 

	  map(filter(level.chars, value.type = 'creature' and
	          find(message.state.creatures,
			       context.value.vars.creature_object.summon_id = value.summon_id) = null),
		 if(dead_object != null,
			set(value.creature_object, dead_object),
			value.destroy())
		  where dead_object = message.state.graveyard[value.creature_object.summon_id]), 
	  [
	  map(message.state.players[message.state.nplayer].hand,
	     spawn('card', 117 + index*card_width, level_height-100, 1,
		   [set(child.vars.in_hand, true),
		    set(child.vars.hand_index, index),
			set(child.zorder, 900+index),
	        set(child.vars.player, message.state.players[message.state.nplayer]),
		    set(child.card_type, value),

			//make the new card animate its way in if it's just been drawn.
			if(size(message.state.players[message.state.nplayer].hand) - index <= drawn_cards, child.animate_draw(index*10))
		  ]))
  where card_width = min(135, if(hand_size, card_area/hand_size, 100))
  where card_area = level_width - 300
  where hand_size = size(message.state.players[message.state.nplayer].hand),
	  if(drawn_cards > 0, reserve_animation_time(30 + 10*size(message.state.players[message.state.nplayer].hand)))
	  ]
		  where drawn_cards =
		    fold([hint.ncards | hint <- animation_hints,
		                        hint.type = 'draw_cards',
							    hint.player_index = message.state.nplayer], a+b),
	  
	  map(message.state.creatures,
	      if(obj != null,
		     //if the object with this summon_id already exists, tell it
			 //about its new internal object.
		     [set(obj.creature_object, value),
			 if(card_rules, set(value.rules, card_rules))],
	      
		  //create a new object to represent this creature.
	      spawn('creature', 0, 0, 1,
				[set(child.creature_object, value), if(card_rules, set(value.rules, card_rules))]))
		  
		  //obj represents the existing object representing this creature.
		  where obj = find(level.chars, value.type = 'creature' and
		                                value.vars.creature_object.summon_id = context.value.summon_id) where card_rules = get_document('data/cards.cfg')[value.name].rules),
										
	  if(message.state.winner, set_widgets(me, {
		type: 'dialog',
		background_alpha: 255,
		background_frame: 'empty_window',
		zorder: 1100,
		rect:[-50, -50, 500, 100],
		children: [
			{
				type:'grid', 
				columns:1, 
				xy:[0,20], 
				column_widths:500, 
				column_alignments:'center', 
				children: [
					{
						type: 'label',
						size: 40, 
						zorder: 1100,
						text: '${message.state.winner.name} Wins!', 
						font: 'RobotoCondensed-Bold', 
						color: 'red'
					},
				]
			}
		],
	  })),

	  set(tmp.last_state_message, message),

	  update_log(message),


fire_event('update_discard_and_deck')


] where animation_hints =
   if(tmp.animation_hints_id != message.state.animation_hints_id,
	  message.state.animation_hints,
	  message.state.animation_hints[tmp.furthest_animation_hint:])
)
",

on_message_received: "[debug('msg: ' + message.type),
  switch(message.type,
		 'game_created',
         [set(vars.client, cl), tbs_send(cl, {type: 'start_game'}), debug('game created')]
		    where cl = tbs_client(TBS_SERVER_ADDRESS, TBS_SERVER_PORT, 1),

         'game',
		 if(message.state.players[message.state.nplayer].deck = null,
		  //submit our deck
		  [
		    //check all the cards in the deck are valid and assert if any aren't
		  	map(get_document('data/player-deck.cfg'), null asserting get_document('data/cards.cfg')[value] != null | 'Unknown card: ' + value),
			tbs_send(vars.client, {type: 'submit_deck', deck: get_document('data/player-deck.cfg')}),
		  ],
	
	    [
	    set(vars.state_id, message.state_id),
		fire_event('update_game', {message: message})
		]
	   ), // end 'game' case.

         //default case.
         [debug('got message: ', message)]),
		 fire_event('request_updates')]",

on_request_updates: "if(vars.client.in_flight = 0,
					      [debug('request_updates: ' + vars.state_id), tbs_send(vars.client, { type: 'request_updates', state_id: vars.state_id })])",
on_connection_error: "[debug('message error', error), fire_event('request_updates')]",

on_process: "
 [
  set(tmp.prev_ctrl_keys, level.player.ctrl_keys),

  if(vars.state.nplayer = vars.state.current_player and
     (enter_key in level.player.ctrl_keys) and
	 not (enter_key in tmp.prev_ctrl_keys), [
	 	if(tmp.spell_animation_time < 78,
		   set(tmp.spell_animation_time, 78)),
		set_widgets([]),
		set_status_label(''),
		tbs_send(vars.client, {
		 type: 'moves',
		 state_id: vars.state_id,
		 moves: [{type: 'end_turn'}]
		})
	  ]
     ) where enter_key = 13,

  if(tmp.response_pause_counter > 0, [
	  add(tmp.response_pause_counter, -1),
	  if(' ' in level.player.ctrl_keys, [
		set(tmp.response_pause_counter, -1),
		if(tmp.timer_bar, remove_object(tmp.timer_bar)),
		set_status_label('Take your time to think about how you want to respond', 'white'),
	  ])
  ]),
  if(tmp.response_pause_counter = 0, [
	set(tmp.response_pause_counter, -1),
	if(tmp.timer_bar, remove_object(tmp.timer_bar)),
	tbs_send(vars.client, {
	 type: 'moves',
	 state_id: vars.state_id,
	 moves: [{type: 'end_turn'}]
	}),
  ]),
  if(tmp.animated_spell_card,
	 if(tmp.spell_animation_time >= 100, [
			 debug('REMOVE SPELL: ' + if(tmp.animated_spell_card in level.chars, true, false)),
		add(tmp.spells_on_stack, [tmp.animated_spell_card]),
		set(tmp.animated_spell_card, null),
		set(tmp.spell_animation_time, 0),
		fire_event(me, 'update_spells_on_stack'),
	 ],

	 //we pause display of the spell at 80 if the user is holding down shift
	 if(tmp.spell_animation_time = 80 and (ctrl_mod_key in [1,2]),
	     reserve_animation_time(20),
	 [
	    add(tmp.spell_animation_time, 1),
		if(tmp.spell_animation_time <= 20, [
			set(tmp.animated_spell_card.alpha, new_alpha),
			map(tmp.animated_spell_card.draw_primitives, set(value.color, [255,0,0,new_alpha]))
			] where new_alpha = if(tmp.spell_animation_time <= 20, tmp.spell_animation_time*22, (100 - tmp.spell_animation_time)*22)
			),
	 ]))), //end animated_spell_card

  if(tmp.game_state_queue != [] and level.cycle >= tmp.animation_end_time,
	[
	  set(tmp.game_state_queue, tmp.game_state_queue[1:]),
	  fire_event('update_game', {message: tmp.game_state_queue[0], force_process: true})
	]),
    if(vars.client, tbs_process(vars.client))
 ]",

on_end_anim: "animation('normal')",
zorder: 50,
timer_frequency: 10,
editor_info: {
	category: "controllers",
	var: [
		{
			name: "x_bound",
			type: "x",
			value: "x-100",
		},
		{
			name: "x2_bound",
			type: "x",
			value: "x+150",
		},
		{
			name: "y_bound",
			type: "y",
			value: "y-100",
		},
		{
			name: "y2_bound",
			type: "y",
			value: "y+150",
		},
	],
},

animation: {
	id: "normal",
	image: "effects/particles.png",
	x: 86,
	y: 73,
	w: 28,
	h: 28,
	collide: [0,0,28,28],
	frames: 1,
	duration: 1000,
},

object_type: [
	{
		id: "heart",
		animation: [
			{
				id: "normal",
				image: "tiles.png",
				rect: [5,67,19,79],
				frames: 1,
			}
		],
	},

	{
		id: "card_back",
		animation: [
			{
				id: "normal",
				image: "card-back.png",
				rect: [0,0,145,203],
				scale: 1,
			},

			{
				id: "front",
				image: "card-citadel.png",
				rect: [0,0,145,203],
				scale: 1,
			},

			{
				id: "hand",
				image: "card-hand.png",
				rect: [0,0,145,203],
				scale: 1,
			},

		],

		properties: {
			set_label: "def(text, font) execute(me, set_widgets([{
				type: 'label',
				text: text,
				font: font,
				size: 28,
				align_h: 'center',
				color: 'black',
				x: 74,
				y: 80,
			}]))",

			set_text: "def(text_list, font) execute(me, set_widgets(
			  map(text_list, {
			  	type: 'label',
				text: value,
				font: font,
				size: 28,
				align_h: 'center',
				color: 'white',
				x: 74,
				y: 40 + index*26
			  })))",

			set_widgets: "def(widgets) execute(me, set_widgets(widgets))",
		},

		tmp: {
			player_index: 0,
		}
	},

	{
		id: "status_label",
		hidden_in_game: true,

		animation: {
			id: "normal",
			image: "effects/particles.png",
			x: 86, y: 73, w: 28, h: 28,
			collide: [0,0,28,28],
			frames: 1,
			duration: 150,
		},

		properties: {
			init_label: "def(text, color='white') execute(me, set_widgets([{
				type: 'label',
				text: text,
				font: 'RobotoCondensed-Regular',
				color: color,
				size: 18,
				x: 100,
				y: level_height - 196,
			}]))",

			level_width: "level.dimensions[2]",
			level_height: "level.dimensions[3]",
		},
	},

	{
		id: "timer_bar",
		hidden_in_game: true,

		tmp: {
			bar: null,
		},

		animation: {
			id: "normal",
			image: "effects/particles.png",
			x: 86, y: 73, w: 28, h: 28,
			collide: [0,0,28,28],
			frames: 1,
			duration: 150,
		},

		on_process: "set(tmp.bar.animation_position, cycle/2.0)",

		properties: {
			create_bar: "def() execute(me, [
				set_widgets([timebar]),
				set(tmp.bar, timebar),
			]
			where timebar = widget(me, {
				type: 'bar',
				id: 'bar',
				left_cap:{area:[0,7,2,7], image:'life.png'}, right_cap:{area:[27,7,3,7], image:'life.png'}, bar:{area:[2,7,2,7], image:'life.png'},
				drained_tick_color: [0,0,0,0],
				bar_color: 'red',
				segments: 1,
				segment_length: 75,
				drained: 1,
				x: 500,
				y: level_height - 196,
			}) 
			)",
			level_width: "level.dimensions[2]",
			level_height: "level.dimensions[3]",
		}
	},

	{
		id: "turn_schedule",
		hidden_in_game: true,

		tmp: {
			state: null
		},

		animation: {
			id: "normal",
			image: "effects/particles.png",
			x: 86, y: 73, w: 28, h: 28,
			collide: [0,0,28,28],
			frames: 1,
			duration: 150,
		},

		properties: {
			create_label: "def(text) {
				type: 'label',
				text: text,
				font: 'RobotoCondensed-Regular',
				size: 12,
				color: 'gray',
			}",

			state: {
				get: "tmp.state",
				set: "execute(me, [
					set(tmp.state, value),
					set_widgets([{
						type: 'grid',
						columns: 2,
						children: [
							create_label(''),
							create_label(value.players[value.turn%size(value.players)].name) + {color: 'white'},
							create_label(''),
							create_label('Turn ' + ((value.turn/size(value.players))+1)) + {color: 'white'},
							create_label(if(not value.done_movement, '-> ', '')),
							create_label('Main Phase'),
							create_label(''),
							create_label('Move Phase') + {color: 'dim_gray'},
							create_label(if(value.precombat_phase, '-> ', '')),
							create_label('Combat Phase'),
							create_label(if(value.done_movement and not value.precombat_phase, '-> ', '')),
							create_label('Main Phase'),
						],
					}])
				])"
			}
		}
	}

],
}
