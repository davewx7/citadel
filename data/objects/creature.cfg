{
	is_strict: true,
	
 	"hitpoints": 1,
	"id": "creature",

	mouse_drag_threshold: 5,

	types: {
		ParticleEffectEntry: "{
			obj: obj particle_controller,
		}"
	},

	on_being_removed: "[
		map(applied_particle_effects, remove_object(value.obj)),
		remove_object(_land_flag),
		map(creature_effects, value.remove()),
		remove_object(_wound),
		set(_wound, null),

		remove_object(land_base),
		set(land_base, null),
	]",

	on_click: "clicked()",

	on_drag_start: "[
		controller.mouse_drag_creature_start(me),
		mouse_drag_start_handler(me),
	]",
	on_drag: "[
		controller.mouse_drag_creature(me),
		mouse_drag_handler(me),
	]",
	on_drag_end: "[
		controller.mouse_drag_creature_end(me),
		mouse_drag_end_handler(me),
	]",
	
	on_mouse_enter: "if(_is_preview = false, [
		map(creature_effects, value.mouse_enter_creature()),
		set(has_mouseover, true),
		animate(me, { mouseover_focus: 1.0 }, { name: 'mouseover', replace_existing: true, duration: int(abs(1.0 - mouseover_focus)*25) }),
	])",
	
	on_mouse_move: "[

	]",

	on_mouse_leave: "if(_is_preview = false, [
		set(has_mouseover, false),
		animate(me, { mouseover_focus: 0.0 }, { name: 'mouseover', replace_existing: true, duration: int(abs(0.0 - mouseover_focus)*25) }),
		if(creature_object, set_gui_stats_alpha(creature_object.stats_alpha))
	])",

	on_process: "[

	  if(land_base, [
		set(land_base.mid_x, mid_x),
		set(land_base.mid_y, mid_y),
		set(land_base.rotate, rotate),
		set(land_base.zorder, zorder-1),
		if(creature_object.controller != _land_base_controller, create_base()),
	  ]),

	  if(_updated, [
		set(_updated, false),

		if(doomed != _currently_doomed, [
			set(_currently_doomed, doomed),
			if(doomed and ctrl.state.in_response_phase and creature_object.controller = ctrl.state.nplayer and ctrl.state.players[ctrl.state.current_player].has_possible_play(ctrl.state), [
				spawn('sweat_effect', {
					targets: [],
					target_creature: me,
				})
			]),

			if(doomed = false and is_engaged = false,
				play_redemption_animation()
			)
		]),

		if(is_engaged != _currently_engaged, [
			set(_currently_engaged, is_engaged),

			if(is_engaged,
				if(enemy_creature, [
					play_engaged_animation(enemy_creature, doomed, enemy_doomed)

				]
				where enemy_doomed = (future_enemy = null)
				where future_enemy = if(ctrl.end_of_turn_state != null, find(ctrl.end_of_turn_state.creatures, value.summon_id = enemy_creature.creature_object.summon_id))
				)
				where enemy_creature = if(targets_attacking, find(level.chars, value is obj creature and value.creature_object._uuid = targets_attacking[0]._uuid))
				where targets_attacking = creature_object.targets_attacking(ctrl.state)
			),
		]),
	  ]
	  	  where is_engaged = creature_object.is_engaged(ctrl.state)
		  where ascended = ctrl.end_of_turn_state != null and doomed and find(ctrl.end_of_turn_state.endzoned_creatures, value = creature_object.summon_id) != null
		  where doomed = (_is_preview = false) and ctrl.end_of_turn_state != null and
		                (creature_object.is_land = false and (future_me = null or future_me.controller != creature_object.controller)
		  where future_me = find(ctrl.end_of_turn_state.creatures, value.summon_id = creature_object.summon_id))
		  where ctrl = controller
	  ),
	  
	  set(_recent_mid, if(size(_recent_mid) > 4, _recent_mid[1:], _recent_mid) + [[mid_x,mid_y]]),
	  set(_recent_mid_latest_cycle, cycle),

	  if(_in_move_animation or _in_summoning_animation or _in_attack_animation or filter(animated_movements, value not in ['mouseover','rampage']) != [],
		 [
		 if(_basexy != null and [mid_x,mid_y] != _basexy,
			animate(me, {
				mid_x: _basexy[0],
				mid_y: _basexy[1],
			}, {
				duration: 5,
			})
		 ),
		 set(_basexy, null), //pass on attack animation right now.
		 ],
	     creature_object.is_on_board and creature_moving = false and _has_unused_movement and controller.in_combat_animation = false,
	  [
	    //Code which handles creatures wanting to move in this block.
	    if(anim_cycle%100 < 18, set(rotate, if(aggressive_anim, 1.0, 0.3)*10*sin((anim_cycle%100)*40)), set(rotate, 0)),
		if(_basexy = null,
		[
		   set(_basexy, [mid_x, mid_y]),
		   set(_basez, zorder),
		   set(zorder, zorder+10),
		],
		   if(cycle_pos < 70, [
			set(mid_y, _basexy[1] + if(in_rampage, 2.0, 1.0) * if(aggressive_anim, 1.0, 0.3)*sin(cycle_pos*360.0/70.0)*cycle_pos*0.5*direction_moving)
		   ], [
		   	set(mid_x, _basexy[0]),
		   	set(mid_y, _basexy[1]),
		   ]),
		) where cycle_pos = (anim_cycle+50)%100 
	  ]
	  where anim_cycle = int(level.cycle * if(in_rampage, 1.1, 1.0))
	  where in_rampage = ('rampage' in creature_object.particle_effects)
	  where aggressive_anim = creature_object.targets_attacking(controller.state) != [],
	  [
	    if(_basexy != null, [
			set(mid_x, _basexy[0]),
			set(mid_y, _basexy[1]),
			set(zorder, int<- _basez),
			set(_basexy, null),
		]),
	  	set(rotate, 0),
	  ]
	  ),

		if(_animate_sizing and _current_sizing != null and (_animate_move_delay <= 0),
		[
			add(_current_sizing, sign(sizing - _current_sizing)*0.01),
			fire_event('render'),
		]),

		//animate captures (change of color) only when creatures have
		//finished moving.
		if(_animate_color and find(level.chars, value is obj creature and value.creature_moving) = null, [
			animate(me, {
				_current_bg_color: bg_color,
			}, {
				on_process: [fire_event('render'), set(me._animate_color, false)],
				duration: 25,
			}),
		]),

		if(_animate_move_delay > 0, add(_animate_move_delay, -1))]",
	
	on_destroy: "[remove_object(me)]",

	on_end_explosion_anim: "destroy()",

	on_type_updated: "fire_event('render')",

	on_render: "[
		set(_dirty, true),
	]",

	on_create: "_recreate_image_texture(creature_object)",

	on_draw: "if(_dirty, [
		set(_dirty, false),
		set_base_tex(),
		[
		[
			//hud_tex.clear_surfaces(),
			set(animation, hud_tex),
		] where hud_tex = instrument('creature_render_hud', render_hud(anim_w, anim_h));

		create_base(),
		]
		  where anim_w = round_to_even(lib.hex.width_from_height(hex_height*sz))
		  where anim_h = round_to_even(hex_height*sz),
		set(_current_bg_color, col),
		set(_animate_color, col != bg_color),
		set(_current_sizing, sz),
		set(_animate_sizing, sz != sizing and sz <= 1.0),

	] where sz = if(_current_sizing != null, _current_sizing, sizing)
	  where col = if(_current_bg_color != null, _current_bg_color, bg_color))",

	properties: {
		_recreate_image_texture: "def(class creature creature) ->commands
	
		[
			set(image_texture, query_cache(lib.gui.image_cache, image_path, get_texture({ image: image_path, surface_flags: ['NO_ALPHA_FILTER', 'NO_CACHE']})))
			  where image_path = sprintf('portraits/card-size/%s', creature.calculate_portrait),
			if(creature.second_portrait != null, [
				set(second_image_texture, query_cache(lib.gui.image_cache, image_path, get_texture({ image: image_path, surface_flags: ['NO_ALPHA_FILTER', 'NO_CACHE']})))
				  where image_path = sprintf('portraits/card-size/%s', creature.second_portrait),
			], [
				set(second_image_texture, null)
			])
		]
		",

		clicked: "def() ->commands
		if(option_index != null,
		    controller.option_clicked(option_index, option_index),
		    _is_preview = false, [
			if(controller.awaiting_input = false and /*arg.mouse_button = 3 and*/ creature_object and creature_object.is_on_board and creature_object.activated_abilities and creature_object.controller = controller.myplayer.player_index,
			[
				swallow_mouse_event(),
				controller.spawn_activated_ability_cards(me)
			],
			    controller.creature_clicked(me),
			),
		])
		",

		tex_mask_x_ratio: "null|decimal :: if(tex_mask, decimal(tex_mask.width)/decimal(img_w))",
		tex_mask_y_ratio: "null|decimal :: if(tex_mask, decimal(tex_mask.height)/decimal(img_h))",

		pending_devotion_animation: { type: "bool", default: false },

		_recent_mid: { type: "[[int,int]]", default: [] },
		_recent_mid_latest_cycle: { type: "int", default: 0 },

		previous_mid_xy: "[int,int] :: if(size(_recent_mid) < 2, [mid_x,mid_y],
		  _recent_mid[size(_recent_mid)-if(_recent_mid_latest_cycle = cycle, 2, 1)])",

		has_mouseover: { type: "bool", default: false },
		mouseover_focus: { type: "decimal", default: 0.0 },

		scale_x: { type: "decimal", default: 1.0 },
		scale_y: { type: "decimal", default: 1.0 },
		scale_rot: { type: "decimal", default: 0.0 },

		hud_alpha: { type: "decimal", default: 1.0 },

		mouse_drag_start_handler: { type: "function(obj creature) ->commands", init: "def(obj creature c)->commands null" },
		mouse_drag_handler: { type: "function(obj creature) ->commands", init: "def(obj creature c)->commands null" },
		mouse_drag_end_handler: { type: "function(obj creature) ->commands", init: "def(obj creature c)->commands null" },

		option_index: { type: "null|int" },

		play_sound: "def(string|null fname) ->commands
			if(_is_preview = false and fname != null, lib.sound.play_sound(me, fname))
		",
	
		regen_start_position: { type: "null|object" },
		regen_attrib_cycle: { type: "null|object" },

		regen_start_cycle: { type: "int", default: 0 },
		regen_end_cycle: { type: "int", default: -1 },

		//this is just an avatar in the status bar and shouldn't show
		//on map etc.
		status_avatar: { type: "bool", default: false },

		furthest_animation_hint: { type: "int", default: 0 },
		texture: { type: "null|object" },

		hex_height: { type: "int" },

		_is_preview: { type: "bool", default: false },

		_animate_move_delay: { type: "int", default: 0 },
		_basexy: { type: "null|Loc" },
		_basez: { type: "null|int" },
		creature_moving: "bool :: level.cycle < _animating_until",
		_animating_until: { type: "null|int" },

		_has_unused_movement: "bool ::
		  _has_animated_movement_since_last_update = false and
		  game_state.current_player_turn_index = creature_object.controller and
		  creature_object.move > creature_object.spaces_moved_this_turn",

		controller: { type: "obj citadel_controller" },
		destroy: "def() ->commands execute(me, fire_event('destroy'))",
		
		set_gui_stats_alpha: "def(decimal alpha_value) ->commands
		  if(stats_grid, set(stats_grid.alpha, int(alpha_value))) where stats_grid = widget|null<- me.widgets.gui_stats_grid",

		hand_card_entered: "def() ->commands [
		]",

		play_summon_animation: "def(class animation.summon_creature_hint hint) ->commands
		 ; [
		 	set(pending_devotion_animation, true),

		    play_sound(hint.creature.sound_summoned),
		  	set(me.alpha, 0),

			if(source_card, [
				set(mid_x, source_card.mid_x),
				set(mid_y, source_card.mid_y),
				source_card.morph_into_creature(me, lib.animation_timings.card_cast_movement_time),
				if(voice_summoned and lib.sound.have_possible_sound(voice_summoned), [
					set(me.hud_alpha, 0.0),
					set(image_scale, (adjustments['scale'] or 1.0) * (adjustments['scale_focus'] or 1.0)),
					set(image_translate_x, (adjustments['translate_x'] or 0.0) + (adjustments['translate_focus_x'] or 0.0)),
					set(image_translate_y, (adjustments['translate_y'] or 0.0) + (adjustments['translate_focus_y'] or 0.0)),
					set(_dirty, true),
				] where adjustments = lib.citadel.card_adjustments[creature_object.name] or {},
				
				[
					set(me.hud_alpha, 0.05),
					schedule(lib.animation_timings.card_cast_movement_time, animate(me, {
						hud_alpha: 1.0,
					}, {
						duration: lib.animation_timings.creature_hud_fade_time,
					})),
				]),
			]),

			animate(me, {
				mid_x: controller.get_tile_pos(target_loc)[0],
				alpha: 255,
			}, {
				easing: lib.math.linear,
				duration: lib.animation_timings.card_cast_movement_time,
				name: 'summoning',
				on_complete: lib.sound.play_sound(me, 'gameplay/place_card_table'),
			}) where target_loc = Loc<- hint.loc,

			animate(me, {
				mid_y: controller.get_tile_pos(target_loc)[1],
			}, {
				easing: lib.math.ease_in_cubic,
				duration: lib.animation_timings.card_cast_movement_time,
			}) where target_loc = Loc<- hint.loc;

			if(voice_summoned and lib.sound.have_possible_sound(voice_summoned),

				let voice = lib.sound.prepare_sound(me, voice_summoned, {delay: 0.7});
				if(voice != null,
					lib.sound.play_prepared_sound(me, voice, voice_summoned);

					sleep(0.7);

					animate(me, {
						image_translate_x: calculate_image_translate_x + 0.1,
					}, {
						duration: if(voice != null, int((voice.duration or 2.0)*60) + 4, 5),
						sleep: true,
						on_process: ; set(me._dirty, true),
					});

					if(image_translate_x = null, set(image_translate_x, calculate_image_translate_x));
					if(image_translate_y = null, set(image_translate_y, calculate_image_translate_y));
					if(image_scale = null, set(image_scale, calculate_image_scale));

					animate(me, {
						hud_alpha: 1.0,
						image_scale: adjustments[sprintf('scale_%s', friend)] or 1.0,
						image_translate_x: adjustments[sprintf('translate_%s_x', friend)] or 0.0,
						image_translate_y: adjustments[sprintf('translate_%s_y', friend)] or 0.0,
					}, {
						duration: 20,
						sleep: true,
						on_process: ; set(me._dirty, true),
					});

					set(image_translate_x, null);
					set(image_translate_y, null);
					set(image_scale, null);
					set(me._dirty, true)
				)
			) where adjustments = lib.citadel.card_adjustments[creature_object.name] or {}
			  where friend = if(creature_object.controller = controller.state.nteam, 'friend', 'enemy'),

			if(not _is_preview, controller.reserve_animation_time('summoning', lib.animation_timings.card_cast_movement_time + 2)),

		  ] where source_card = find(level.chars, _is_preview = false and value is obj card and value.stack_id is int and value.card_type.name = hint.creature.card_name)
		    where voice_summoned = if(lib.sound.is_voice_playing(me) = false, creature_object.calculate_voice_summoned(game_state))
		",

		play_voice_hint: "def(class animation.creature_voice_hint hint) ->commands
		;
		if(lib.sound.is_voice_playing(me) = false and lib.sound.have_possible_sound(hint.sound_event),
			let voice = lib.sound.prepare_sound(me, hint.sound_event);
			if(voice != null,
				lib.sound.play_prepared_sound(me, voice, hint.sound_event);

				if(image_scale = null, set(image_scale, calculate_image_scale));
				if(image_translate_x = null, set(image_translate_x, calculate_image_translate_x));
				if(image_translate_y = null, set(image_translate_y, calculate_image_translate_y));

				animate(me, {
					hud_alpha: 0.0,
					image_scale: (adjustments['scale'] or 1.0) * (adjustments['scale_focus'] or 1.0),
					image_translate_x: (adjustments['translate_x'] or 0.0) + (adjustments['translate_focus_x'] or 0.0),
					image_translate_y: (adjustments['translate_y'] or 0.0) + (adjustments['translate_focus_y'] or 0.0),
				}, {
					duration: 20,
					on_process: ; set(me._dirty, true),
					sleep: true,
				});

				animate(me, {
					image_translate_x: calculate_image_translate_x + 0.1,
				}, {
					duration: if(voice != null, int((voice.duration or 2.0)*60) + 4, 5),
					sleep: true,
					on_process: ; set(me._dirty, true),
				});

				if(image_translate_x = null, set(image_translate_x, calculate_image_translate_x));
				if(image_translate_y = null, set(image_translate_y, calculate_image_translate_y));
				if(image_scale = null, set(image_scale, calculate_image_scale));

				animate(me, {
					hud_alpha: 1.0,
					image_scale: adjustments[sprintf('scale_%s', friend)] or 1.0,
					image_translate_x: adjustments[sprintf('translate_%s_x', friend)] or 1.0,
					image_translate_y: adjustments[sprintf('translate_%s_y', friend)] or 1.0,
				}, {
					duration: 20,
					on_process: ; set(me._dirty, true),
					sleep: true,
				});

				set(image_translate_x, null);
				set(image_translate_y, null);
				set(image_scale, null);
				set(me._dirty, true)
			)
			where adjustments = lib.citadel.card_adjustments[creature_object.name] or {}
			where friend = if(creature_object.controller = controller.state.nteam, 'friend', 'enemy'),
		)
		",

		play_animation_hint: "def(class creature obj, map hint) ->commands execute(me, if(not _is_preview, switch(hint.type,

		  'regeneration', [
		    log(['REGEN SOUND', obj.sound_regeneration]),
		    play_sound(obj.sound_regeneration),
		  	set(regen_start_cycle, cycle+10),
		  	set(regen_end_cycle, cycle+70),
		  ],
		  null)))",

		furthest_attack_id: { type: "int", default: -1 },

		play_death_animation: "def(class animation.creature_die_hint hint) ->commands

		if(controller != null,
		[
			map(applied_particle_effects, value.obj.fade_away_and_die()),

			controller.reserve_animation_time('creature_death', 30),
			animate(me, {
				alpha: 0,
			}, {
				duration: 25,
				on_complete: me.destroy(),
			}),

			if(hint.obliterated, set(color_adjust, [0.0,0.0,0.0,1.0])),

			if(hint.creature.death_animation_hint,
				spawn(hint.creature.death_animation_hint, {
					mid_x: mid_x,
					mid_y: mid_y,
					target_creature: me,
					targets: [],
					zorder: me.zorder + 20,
					_scaling: 1.8,
				})
			),

			if(voice_die and lib.sound.have_possible_sound(voice_die),
				lib.sound.play_sound(me, voice_die),
				hint.creature.sound_death,
				lib.sound.play_sound(me, hint.creature.sound_death)
			)

		]
		where voice_die = if(lib.sound.is_voice_playing(me) = false, creature_object.calculate_voice_die(game_state))
		)",

		play_redemption_animation: "def() ->commands
		if(voice_redemption != null,
		schedule(40,
			play_voice_hint(construct('animation.creature_voice_hint', {
				creature: creature_object,
				sound_event: voice_redemption,
			}))
		)
		)

		where voice_redemption = if(lib.sound.is_voice_playing(me) = false, creature_object.calculate_voice_redemption(game_state))
		",

		play_engaged_animation: "def(obj creature enemy_creature, bool doomed, bool enemy_doomed) ->commands
		if(sound_event != null,
			schedule(20,
				play_voice_hint(construct('animation.creature_voice_hint', {
					creature: creature_object,
					sound_event: sound_event,
				}))
			)
		)
			where sound_event = if(lib.sound.is_voice_playing(me) = false, creature_object.calculate_voice_engaged(game_state, enemy_creature.creature_object, doomed, enemy_doomed))
		",

		_extend_bloodcord: "def(obj player_avatar target) ->commands if(controller is obj citadel_controller, [
			lib.sound.play_sound(me, 'gameplay/blood-altar-zap'),
			
			spawn('creature_particle_effect', mid_x, mid_y, {
				_creature: me,
				zorder: me.zorder+10000,
				mid_x: mid_x,
				mid_y: mid_y,
				alpha: 0,
			}, [
				child.bloodcord(target),

				animate(child, {
					alpha: 255,
				}, {
					name: 'bloodcord',
					duration: 20,
					replace_existing: false,
				}),
	
				animate(child, {
					alpha: 0,
				}, {
					name: 'bloodcord',
					duration: 20,
					replace_existing: false,
					on_complete: remove_object(child),
				}),
			]),

			schedule(20,
			   [
			   	target.flash_hit(),
			    ; (lifebar.set_life(lifebar.current_life-1) where lifebar = controller.avatar_life[target.player_num]),
			   ])
		])",
		 // where delta_y = int((target.mid_y - y)*0.1) + 1d(lib.gui.px(50)) - 1d(lib.gui.px(50))",

		play_endzone_animation: "def(int damage, int intensity, null|int target_index=null, null|string anim_type=null) ->commands
		if(controller is obj citadel_controller,
	    if(animation_type = 'bloodcord', [

			controller.reserve_animation_time('player_damage', 25),

			bind_command(_extend_bloodcord, target_avatar),
		],
		
		//normal player damage animation
		[
			lib.sound.play_sound(me, creature_object.sound_breach),
			animate(me, { zorder: 20000, size_override: 1.5, hud_alpha: 0.0, mid_x: level_mid_x, mid_y: level_mid_y, image_zoom_override: 0.3 }, { name: 'endzone', duration: lib.animation_timings.creature_attack_player_zoom_time }),

			animate(me, { mid_x: target_x, mid_y: target_avatar.mid_y, scale_x: 0.9, scale_y: 1.1 }, {
				name: 'endzone',
				duration: lib.animation_timings.creature_attack_player_windup_time,
				easing: def(decimal ratio)->decimal sin(ratio*90.0 - 180.0)*0.2,
			}),
			animate(me, {
				mid_x: target_x,
				mid_y: target_avatar.mid_y,
				scale_x: 1.2,
				scale_y: 0.8,
				image_zoom_override: 1.0
			}, {
				name: 'endzone',
				duration: lib.animation_timings.creature_attack_player_lunge_time,
				easing: def(decimal ratio)->decimal ratio,
				on_complete: [
				  lib.sound.play_sound(me, sprintf('gameplay/player_impact_%s', if(intensity <= 7, 'low', intensity >= 15, 'high', 'medium'))),
				  controller.screen_shake(min(20, damage*2), 30, 5),
				  target_avatar.flash_hit(),
				  ; (lifebar.set_life(lifebar.current_life - damage) where lifebar = controller.avatar_life[target_avatar.player_num])
				]
			}
			),
			animate(me, {mid_x: level_mid_x, mid_y: level_mid_y, scale_x: 1.0, scale_y: 1.0 },{
				name: 'endzone',
				duration: lib.animation_timings.creature_attack_player_moveback_time,
				easing: def(decimal ratio)->decimal ratio*0.2,
			}),
			animate(me, { mid_x: level_mid_x, mid_y: level_mid_y }, {
				name: 'endzone',
				duration: lib.animation_timings.creature_attack_player_withdraw_time,
				easing: def(decimal ratio)->decimal ratio*0.5,
			}),
			animate(me, { mid_x: level_mid_x, mid_y: level_mid_y, alpha: 0, scale_x: 1.5, scale_y: 1.5 }, { name: 'endzone', duration: lib.animation_timings.creature_attack_player_fadeout_time, easing: def(decimal ratio)->decimal ratio, on_complete: remove_object(me) }),

		]) where target_x = if(target_avatar.mid_x > me.mid_x, target_avatar.x, target_avatar.x + target_avatar.img_w)
		  where target_y = level_mid_y
		  where target_avatar = find_or_die(level.chars, value is obj player_avatar and if(target_index = null, controller.state.team_index(creature_object.controller) != controller.state.team_index(value.player_num), target_index = controller.state.team_index(value.player_num)))
		  where level_mid_x = controller.level_width/2
		  where level_mid_y = controller.level_height/2
		  where animation_type = anim_type or creature_object.attack_player_anim
		 )
		  ",

		_display_life: { type: "int|null" },
		displayed_life: "int :: if(_display_life != null, _display_life, creature_object.net_life)",
		displayed_life_shield: "int :: if(_display_life != null and _display_life < creature_object.net_life, creature_object.life_shield - (creature_object.net_life - _display_life), creature_object.life_shield)",

		_has_animated_movement_since_last_update: { type: "bool", default: false },

		animate_movement: "def(Loc to, string anim_type) ->commands [
			set(_has_animated_movement_since_last_update, true),

			if(anim_type = 'astral walk',
						[

			//Add a 'blur object' which remains in our current position, and
			//represents 'us' to the player. The real object will move forward
			//and then the blur object will disappear.
			add(me.blur,
			[
			 blur_object({
				alpha: 255,
				mid_x: mid_x,
				mid_y: mid_y,
				color_adjust_anim: [1.0,1.0,1.0,1.0],
				bright_adjust: 0.0,

			}, {
				duration: int(lib.animation_timings.creature_move_time*1.0),
			})
			]
			),

			//Create another blur object in place of the old one that have much
			//higher bright_adjust giving it a brief flash to represent it
			//'jumping' to the object's position.
			schedule(int(lib.animation_timings.creature_move_time*1.0),
			add(me.blur,
			[
			 blur_object({
				alpha: 255,
				mid_x: mid_x,
				mid_y: mid_y,
				color_adjust_anim: [1.0,1.0,1.0,1.0],
				bright_adjust: 0.0,

			}, {
				duration: int(lib.animation_timings.creature_move_time*0.1),
				animate: {
					bright_adjust: 2.0,
					alpha: 0,
				}
			})
			]
			)
			),

			animate(me, {
				alpha: 50,
			}, {
				duration: int(lib.animation_timings.creature_move_time*0.1),

			}),

			animate(me, {
				color_adjust_anim: [0.0,0.0,0.7,1.0],
			}, {
				duration: int(lib.animation_timings.creature_move_time*0.1),
			}),

			animate(me, {
				mid_x: end_x,
				mid_y: end_y,
				bright_adjust: 0.8,

			}, {
				duration: int(lib.animation_timings.creature_move_time*0.7),
				name: 'move',
				easing: lib.easing.get_curve('astral_walk').fn,
				replace_existing: true,

				on_process: ; add(me.blur,
				
				map(range(6),
				 blur_object({
					mid_x: int(mix(previous_pos[0], me.mid_x, value/6.0)),
					mid_y: int(mix(previous_pos[1], me.mid_y, value/6.0)),
					alpha: 20,
					color_adjust_anim: [0.0,0.0,1.0,1.0],
				}, {
					duration: 6,
					animate: {
						alpha: 0,
					},
				})
				)
				 where previous_pos = previous_mid_xy

				)
			}),


			schedule(int(lib.animation_timings.creature_move_time*0.9),
			animate(me, {
				alpha: 255,
				color_adjust_anim: [1.0,1.0,1.0,1.0],
			}, {
				duration: int(lib.animation_timings.creature_move_time*0.1),
				easing: lib.math.ease_in_back,
				name: 'astral walk',
				replace_existing: false,

			})),

			//At the end give a brief 'flash' of bright_adjust to represent the object being
			//'teleported' to before reverting bright_adjust to 0.
			schedule(lib.animation_timings.creature_move_time, set(bright_adjust, 2.0)),
			schedule(int(lib.animation_timings.creature_move_time*1.05), set(bright_adjust, 0.0)),

			]),

			if(anim_type = 'blink',
			[
			lib.sound.play_sound(me, 'gameplay/spell_blink'),
			blink_particles(),
			animate(me, {
				scale: 0,
			}, {
				duration: 10,
				name: 'blink',
			}),
			schedule(25, blink_particles_end()),
			schedule(25, animate(me, {
				scale: 1,
			}, {
				duration: 10,
				name: 'blink',
			})),
			schedule(10, animate(me, {
				mid_x: end_x,
				mid_y: end_y,
			}, {
				duration: 1,
				name: 'blink',
			}))
			]),

			if(anim_type = 'swap',
			[
			set(_basexy, null),
			controller.reserve_animation_time('move_swap', 45),

			animate(me, {
				scale_x: 1.2,
				scale_y: 0.9,
				rotate: 0,
			}, {
				duration: 12,
				name: 'stretch',
			}),

			animate(me, {
				scale_x: 1.0,
				scale_y: 1.0,
			}, {
				duration: 12,
				name: 'stretch',
			}),

			animate(me, {
				scale_x: 1.2,
				scale_y: 0.9,
			}, {
				duration: 12,
				name: 'stretch',
			}),

			animate(me, {
				scale_x: 1.0,
				scale_y: 1.0,
			}, {
				duration: 12,
				name: 'stretch',
			}),

			animate(me, {
				mid_x: end_x + controller.tile_width * if(end_y < mid_y, -1, 1),
				mid_y: (mid_y+end_y)/2,
			}, {
				duration: 25,
				name: 'move',

				on_process: ; add(me.blur,
				
				map(range(10),
				 blur_object({
					mid_x: int(mix(previous_pos[0], me.mid_x, value/10.0)),
					mid_y: int(mix(previous_pos[1], me.mid_y, value/10.0)),
					alpha: 8,
				}, {
					duration: 6,
					animate: {
						alpha: 0,
					},
				})
				)
				 where previous_pos = previous_mid_xy
				)
			}),
			animate(me, {
				mid_x: end_x,
				mid_y: end_y,
			}, {
				duration: 15,
				name: 'move',
			})
			]),

			if(anim_type = 'leap',
			[
			set(scale_rot, atan2(mid_x - end_x, mid_y - end_y)),

			animate(me, {
				scale_y: 1.4,
				scale_x: 0.7,
			}, {
				duration: int(lib.animation_timings.creature_move_time*0.6),
				name: 'stretch',
				easing: lib.math.ease_in_out_back,
				replace_existing: true,
			}),

			animate(me, {
				scale_y: 1.0,
				scale_x: 1.0,
			}, {
				duration: int(lib.animation_timings.creature_move_time*0.2),
				name: 'stretch',
				easing: lib.math.ease_in_out_back,
				replace_existing: false,
				on_complete: set(me.scale_rot, 0.0),
			}),

			animate(me, {
				mid_x: end_x,
				mid_y: end_y,
			}, {
				duration: int(lib.animation_timings.creature_move_time*0.6),
				name: 'move',
				easing: lib.math.ease_in_back,

				on_process: ; add(me.blur,
				
				map(range(10),
				 blur_object({
					mid_x: int(mix(previous_pos[0], me.mid_x, value/10.0)),
					mid_y: int(mix(previous_pos[1], me.mid_y, value/10.0)),
					alpha: 8,
				}, {
					duration: 6,
					animate: {
						alpha: 0,
					},
				})
				)
				 where previous_pos = previous_mid_xy

				)
			})
			]),

			if(anim_type = 'move',
			[
			lib.sound.play_sound(me, 'gameplay/unit_movement'),
			animate(me, {
				mid_x: end_x,
				mid_y: end_y,
			}, {
				duration: lib.animation_timings.creature_move_time,
				name: 'move',
			})
			]),
		]
		where end_x = calculate_x(to)
		where end_y = calculate_y(to)",

		color_adjust: {
			type: "[decimal,decimal,decimal,decimal]",
			default: [1.0,1.0,1.0,1.0],
			set: "if(value != _data, [
				set(_data, value),
				animate(me, {
					color_adjust_anim: value,
				}, {
					duration: 20,
				})
			])",
		},

		color_adjust_anim: {
			type: "[decimal,decimal,decimal,decimal]",
			default: [1.0,1.0,1.0,1.0],
		},

		_poisoned: {
			type: "bool",
			default: false,
			set: "if(value != _data, [
				set(_data, value),
				set(color_adjust, map(color_adjust, if(index = 1, if(context.value, 0.5, -0.5), 0.0) + value)),
			])",
		},

		_wound: { type: "null|obj wound_effect" },

		creature_effects: {
			type: "[obj creature_effect]",
			default: [],
		},

		add_creature_effect: "def(string effect_name, map|null args=null) ->commands
		if(effect_name not in map(creature_effects, value.type),
			spawn(effect_name, {
				mid_x: mid_x,
				mid_y: mid_y,
				zorder: zorder+10,
				creature: me,
				controller: controller
			} + if(args, args, {}), [
				add(creature_effects, [obj creature_effect<- child])
			]
			)
		)
		",

		creature_object: {
		type: "class creature",
		set_type: "class creature",
		default: null,
		set: "
		  execute(me, if(status_avatar, set(_data, value),
		  [
		    set(_updated, true),
		    set(_has_animated_movement_since_last_update, false),
			set(_poisoned, 'Poisoned' in value.status_effects),
		    set(me.attached_objects, []),
		    set(me.alpha, 255),
		    set(_data, value),

			_recreate_image_texture(value),

		    set(hue_shift, if(value.base_card != null, if(hue is decimal, hue, 0.0) where hue = value.base_card.hue_shift, 0.0)),

			if(value.life >= value.starting_life and _wound != null, [
				set(_wound, null),
				animate(_wound, {
					alpha: 0,
				}, {
					duration: 10,
					on_complete: remove_object(_wound),
				})
			]),

			set(me._display_life, value.net_life),

			[
				[effect.remove() | effect <- creature_effects, effect.type not in effect_types],
				set(creature_effects, filter(creature_effects, value.type in effect_types)),

				; schedule(if(cycle = 0, 120, 0), [add_creature_effect(effect.type, effect.args) | effect <- effect_tags]),
			]
			where effect_types = map(effect_tags, value.type)
			where effect_tags = value.effect_tags,

			if(value.is_on_board,

			 [

			 (if(_data = null,
			     set(me.mid_xy, [target_x, target_y]),

				//_data != null meaning we're updating the object
				//rather than being a new object
			    [

				if(_basexy,
		   			set(_basexy, [target_x, target_y]),
					set(me.mid_xy, [target_x, target_y])
				),

				//spawn a life change label
				if(_display_life != null and _display_life != value.net_life,
				   spawn('label', mid_x, mid_y, {
						zorder: me.zorder+1000,
						_text: [str(value.net_life - _display_life)],
						red: if(_display_life > value.net_life, 255, 0),
						green: if(_display_life < value.net_life, 255, 0),
						blue: 0,
				   }, [
				   	animate(child, {
						mid_y: mid_y - 80,
					}, {
						duration: 50,
						on_complete: remove_object(child),
					}),
				   ])),

					if(_data.net_life != value.net_life,
					[
		  			controller.reserve_animation_time('creature_life_change', controller.animation_move_time + 40),
					]) asserting shader,
				 ])
			   )
			 ]
			   where target_x = calculate_x(value.loc)
			   where target_y = calculate_y(value.loc)
		   ), //end value.is_on_board
			if(value.is_on_board, set(me.zorder, (value.loc[0]+1)*10 + if(not value.is_land, 100, 0))),


			[play_animation_hint(value, hint) |
			 hint <- value.animation_hints,
			 hint.hint_id > furthest_animation_hint],

			if(value.animation_hints, set(furthest_animation_hint, int<- value.animation_hints[size(value.animation_hints)-1].hint_id)),

			fire_event('render'),
			set_particle_effects(value.particle_effects),

			if(value.is_land and value.controller != -1,

			if(_land_flag = null or _land_flag.is_enemy != is_enemy or capture_anim,
			spawn('creature_land_flag', 0, 0, {
				controller: controller,
				creature: me,
				is_enemy: value.controller != controller.state.nplayer,
				zorder: 0,
			}, [
				if(capture_anim != null,
					child.animate_flag_raise()
				),
				set(_land_flag, child),
			])) where is_enemy = value.controller != controller.state.nplayer
			   where capture_anim = find(value.animation_hints, value.hint_id > furthest_animation_hint and value.type = 'captured'),

			set(_land_flag, null),
			)
			]))"
	  },

	  calculate_x: "def(Loc loc) ->int controller.get_tile_pos(loc)[0]",
	  calculate_y: "def(Loc loc) ->int controller.get_tile_pos(loc)[1]",
	  
	  get_hit_animation: "def(int damage) ->commands execute(me, [
		set(shader.uniform_commands.is_flashing, true) asserting shader,
		schedule(3, set(shader.uniform_commands.is_flashing, false)) asserting shader,

		if(damage > 0, [
			set(_display_life, displayed_life - damage),
			set(_dirty, true),

			if(_wound = null and creature_object.is_building = false,
				spawn('wound_effect', {
					time_in_animation: 1d3 - 1,
					creature: me,
					controller: controller,
				}, [
					set(_wound, child),
				])
			),

			spawn_damage_label(damage),

		]),
	  ])",

	  spawn_damage_label: "def(int damage) ->commands
	  if(damage != 0,
		map(range(2),
		spawn('label', int(x + img_w*0.66) + lib.gui.py(value*3), mid_y + lib.gui.py(50)*direction_moving + lib.gui.py(value*3), {
					zorder: me.zorder+1000-value,
					_text: [str(abs(damage))],
					_font: lib.font.bold_font,
					red: if(damage > 0 and not is_shadow, 255, 0),
					green: 0,
					blue: if(damage < 0 and not is_shadow, 255, 0),
					alpha: if(is_shadow, 196, 255),
			   }, [
			   	animate(child, {
					mid_y: child.mid_y - 80,
				}, {
					duration: 80,
					on_complete: remove_object(child),
				}),
		   ])
		  where is_shadow = index > 0
		 )
		)
	  ",
	  
	  drain_animation: "def(int drain, obj creature target_creature) ->commands execute(me, [
		if(drain > 0, [
			lib.sound.play_sound(me, 'gameplay/life-drain'),
			set(_display_life, displayed_life + drain),
			set(_dirty, true),

			spawn_damage_label(-drain),

			map(range(60),
				spawn('game_icon', 0, 0, {
					size: lib.gui.px(32),
					icon: 'drop.svg',
					blue: 0,
					green: 0,
					red: 128,
					alpha: 32 + 1d64,
					mid_x: target_creature.mid_x + 1d(lib.gui.px(64)) - 1d(lib.gui.px(64)),
					mid_y: target_creature.mid_y + 1d(lib.gui.px(64)) - 1d(lib.gui.px(64)),
					zorder: 2000,
				}, [
					animate(child, {
						mid_x: mid_x,
						mid_y: mid_y,
						alpha: 0,
					}, {
						duration: 20,
						on_complete: remove_object(child),
					}),
				]
				)
			)
		]),
	  ])",

	  spawn_attack_info_label: "def(string text) ->commands execute(me, [
			spawn('label', mid_x, mid_y, {
						zorder: me.zorder+1000,
						_text: [text],
						_font_size: lib.gui.px(24),
						red: 255,
						green: 255,
						blue: 255,
				   }, [
				    schedule(50, remove_object(child))
				   ]),
	  ])",

	  _in_move_animation: "bool :: 'move' in animated_movements",
	  _in_summoning_animation: "bool :: 'summoning' in animated_movements",

	  _in_attack_animation: { type: "bool", default: false },
	  play_attack_animation: "def(class animation.creature_attack_hint attack_hint) ->commands
	  if(controller is obj citadel_controller,
	  execute(me, [
		if(target_creature != null,
		[
		   controller.reserve_animation_time('creature_attack_animation', lib.animation_timings.creature_attack_animation_total_time),

		   set(_in_attack_animation, true),

		   add(me.zorder, 100),

		   animate(me, {
			rotate: 0.0,
		   }, {
			name: 'straighten',
			duration: 5,
		   }),

		   if(attack_hint.first_strike, spawn_attack_info_label('First Strike!')),

		   if(creature_object.is_melee,
		   [
		      add(me.brightness, 50),
			   play_sound(creature_object.sound_attack),
			   animate(me, {
				 mid_x: target_x,
				 mid_y: target_y,
				 scale_y: 0.88,
				 scale_x: 1.08,
			   }, {
				 name: 'attack',
				 easing: def(decimal ratio)->decimal
				   sin(ratio*90.0 - 180.0)*0.2,
				 duration: lib.animation_timings.creature_attack_animation_windup_time,

				 on_complete: ; if(creature_object.sound_swish != null, play_sound(sprintf('gameplay/swish_%s', creature_object.sound_swish))),
			   }),

			   animate(me, {
				 rotate: 0.0,
				 scale_y: 0.85,
				 scale_x: 1.1,
			   }, {
				 name: 'attack',
				 duration: lib.animation_timings.creature_attack_animation_windup_time/2,
			   }),

			   animate(me, {
				 mid_x: target_x,
				 mid_y: target_y,
				 scale_y: 1.4,
				 scale_x: 0.6,
			   }, {
				 name: 'attack',
				 easing: def(decimal ratio)->decimal ratio*0.7,
				 on_begin: map(filter(effects, value != null),
				 	schedule(lib.animation_timings.creature_attack_animation_lunge_time - timing,
						target_creature.spawn_effect(value.effect)
					)
				 where timing = if(value.frames_ahead, value.frames_ahead, 0)
				 ) where effects = creature_object.damage_creature_effect(target_creature.creature_object, attack_hint.damage),
				 on_complete: [
				 	controller.screen_shake(min(20, int(attack_hint.damage*1.5)), 30, 5),
					[
						play_sound(sprintf('gameplay/combat_impact_%s_%s', creature_object.sound_impact, target_creature.creature_object.sound_impact)),
						target_creature.get_hit_animation(attack_hint.damage),
						if(imprint is string and attack_hint.damage >= target_creature.creature_object.life, target_creature.set_tex_mask(imprint))
						where imprint = creature_object.attack_creature_imprint(target_creature.creature_object, attack_hint.damage),
						drain_animation(attack_hint.drain, target_creature),
					],
				 ],
				 duration: lib.animation_timings.creature_attack_animation_lunge_time,
				 replace_existing: false,
			   }),

			   animate(me, {
				 mid_x: mid_x,
				 mid_y: mid_y,
				 scale_y: 1.0,
				 scale_x: 1.0,
			   }, {
					 name: 'attack',
				 easing: def(decimal ratio)->decimal ratio*0.2,
				 duration: lib.animation_timings.creature_attack_animation_finish_time/5,
				 replace_existing: false,
			   }),

			   animate(me, {
				 mid_x: if(_basexy, _basexy[0], mid_x),
				 mid_y: if(_basexy, _basexy[1], mid_y),
				 scale_y: 1.0,
				 scale_x: 1.0,
			   }, {
				 name: 'attack',
				 replace_existing: false,
				 duration: (lib.animation_timings.creature_attack_animation_finish_time*4)/5,
				 on_complete: [set(_in_attack_animation, false), add(me.zorder, -100)],
			   }),

		   	   schedule(50, add(me.brightness, -50)),
		   ],

		   //ranged attack

		   creature_object.attack_creature_anim = 'gunfire' or creature_object.is_ranged,
		   [
			    play_sound(creature_object.sound_attack),
				play_sound('gameplay/musket_fire'),
				schedule(32, ; target_creature.get_hit_animation(attack_hint.damage)),
				schedule(32, ; drain_animation(attack_hint.drain, target_creature)),

				let start_mid_x = mid_x;
				let start_mid_y = mid_y;

				animate(me, {
					mid_x: start_mid_x + lib.gui.py(5),
					mid_y: start_mid_y + lib.gui.py(1d6) - lib.gui.py(1d6),
				}, {
					duration: 3,
					sleep: true,
				});

				animate(me, {
					mid_x: start_mid_x - lib.gui.py(5),
					mid_y: start_mid_y + lib.gui.py(1d6) - lib.gui.py(1d6),
				}, {
					duration: 3,
					sleep: true,
				});

				animate(me, {
					mid_x: start_mid_x + lib.gui.py(5),
					mid_y: start_mid_y + lib.gui.py(1d6) - lib.gui.py(1d6),
				}, {
					duration: 3,
					sleep: true,
				});

				animate(me, {
					mid_x: start_mid_x - lib.gui.py(5),
					mid_y: start_mid_y + lib.gui.py(1d6) - lib.gui.py(1d6),
				}, {
					duration: 3,
					sleep: true,
				});

				animate(me, {
					mid_x: start_mid_x,
					mid_y: start_mid_y,
				}, {
					duration: 2,
					sleep: true,
				});

				map(range(8),
					spawn('projectile_bullet', {
						mid_x: mid_x,
						mid_y: mid_y,
						target_x: target_x + lib.gui.py(1d30) - lib.gui.py(1d30),
						target_y: target_y + lib.gui.py(1d12) - lib.gui.py(1d12),
						zorder: me.zorder+1000,
					})
				);

				spawn('muzzle_flash_effect', {
					mid_x: mid_x,
					mid_y: mid_y - sign(mid_y - target_y)*lib.gui.py(40),
					zorder: zorder + 2000,
					scale: lib.gui.dpy(0.3),
					alpha: 255,
					rotate: 90,
				}, [
					animate(child, {
						alpha: 255,
					}, {
						duration: 3,
						on_complete: remove_object(child)
					})
				]);
/*
				spawn('smoke', {
					mid_x: mid_x,
					mid_y: mid_y,
					zorder: me.zorder+2000,
					width: lib.gui.dpy(10.0),
					height: lib.gui.dpy(10.0),
				}, [
					animate(child, {
						mid_x: mid_x - lib.gui.py(2000),
					}, {
						duration: 300,
						easing: lib.math.ease_in_quint,
						on_complete: remove_object(child),
					}),

					animate(child, {
						mid_y: mid_y - lib.gui.py(50),
						width: lib.gui.dpy(512.0),
						height: lib.gui.dpy(512.0),
					}, {
						duration: 500,
						easing: lib.math.ease_out_sine,
					}),
				]);
*/
				animate(me, {
					mid_y: mid_y + sign(mid_y - target_y)*lib.gui.py(50),
				}, {
					duration: 5,
					sleep: true,
				});

				animate(me, {
					mid_y: start_mid_y
				}, {
					duration: 30,
					sleep: true,
				});

				set(_in_attack_animation, false)
		   ],

		   [
			    play_sound(creature_object.sound_attack),
		   		spawn('game_icon', 0, 0, {
					size: lib.gui.px(48),
					icon: 'ranged-icon.svg',
					mid_x: mid_x,
					mid_y: mid_y,
					zorder: 2000,
				}, [
					animate(child, {
						mid_x: target_x,
						mid_y: target_y,
					}, {
						duration: 20,
						on_complete: [
							[
								target_creature.get_hit_animation(attack_hint.damage),
								drain_animation(attack_hint.drain, target_creature),
							],

							remove_object(child),
						]
					}),
				]
				),

				schedule(50, [set(_in_attack_animation, false), add(me.zorder, -100)])
		   ]),


		] where target_x = calculate_x(target_creature.creature_object.loc)
		  where target_y = calculate_y(target_creature.creature_object.loc)
		)
		  where target_creature = find(level.chars, value is obj creature and value.creature_object.summon_id = attack_hint.defender.summon_id)
	  ]
	  )
	  )
	",

	play_shatter_seal_animation: "def(obj seal target) ->commands 
	if(controller is obj citadel_controller,
	execute(me, [
		controller.reserve_animation_time('shatter_seal', 60),
		add(me.zorder, 100),
		set(_in_attack_animation, true),
		animate(me, {
			rotate: 0.0,
		}, {
			name: 'straighten',
			duration: 5,
		}),
		animate(me, {
			mid_x: target.mid_x,
			mid_y: target.mid_y,
			scale_y: 0.88,
			scale_x: 1.08,
		}, {
			name: 'attack',
			easing: def(decimal ratio)->decimal
			sin(ratio*90.0 - 180.0)*0.2,
			duration: lib.animation_timings.creature_attack_animation_windup_time,
		}),

		animate(me, {
			rotate: 0.0,
			scale_y: 0.85,
			scale_x: 1.1,
		}, {
			name: 'attack',
			duration: lib.animation_timings.creature_attack_animation_windup_time/2,
		}),

		animate(me, {
			mid_x: target.mid_x,
			mid_y: target.mid_y,
			scale_y: 1.4,
			scale_x: 0.6,
		}, {
			name: 'attack',
			easing: def(decimal ratio)->decimal ratio*0.7,
			on_complete: [
			controller.screen_shake(min(20, int(target.seal_damage*1.5)), 30, 5),
		 	[
				
			   	if(player_avatar, player_avatar.flash_hit()) where player_avatar = find(level.chars, value is obj player_avatar and value.player_num = target.player_num),
			    ; (lifebar.set_life(lifebar.current_life-target.seal_damage) where lifebar = controller.avatar_life[target.player_num]),
				lib.sound.play_sound(me, sprintf('gameplay/break_seal_%s', if(target.damage <= 8, 'light', target.damage >= 15, 'heavy', 'medium'))),
				target.shatter_animation(),
				remove_object(target),
		 	],
			],
			duration: lib.animation_timings.creature_attack_animation_lunge_time,
			replace_existing: false,
		}),

		animate(me, {
			mid_x: mid_x,
			mid_y: mid_y,
			scale_y: 1.0,
			scale_x: 1.0,
		}, {
		 	name: 'attack',
			easing: def(decimal ratio)->decimal ratio*0.2,
			duration: lib.animation_timings.creature_attack_animation_finish_time/5,
			replace_existing: false,
		}),

		animate(me, {
			mid_x: if(_basexy, _basexy[0], mid_x),
			mid_y: if(_basexy, _basexy[1], mid_y),
			scale_y: 1.0,
			scale_x: 1.0,
		}, {
			name: 'attack',
			replace_existing: false,
			duration: (lib.animation_timings.creature_attack_animation_finish_time*4)/5,
			on_complete: [set(_in_attack_animation, false), add(me.zorder, -100)],
		}),
	]))
	",

	  loc_on_screen: "def(Loc loc) ->Loc [loc[0], if(game_state.nteam = 0, (game_state.columns-1) - loc[1], loc[1])]",

	  game_state: { type: "class game_state" },
	  direction_moving: "int :: if(game_state.nteam = creature_object.controller, 1, -1)",

      _animate_sizing: { default: false },
	  _current_sizing: { type: "null|decimal" },

	  size_override: { variable: false, type: "decimal", get: "if(_current_sizing != null, _current_sizing, sizing)", set: "[set(_dirty, true), set(_current_sizing, value)]" },

	  sizing: "decimal :: 0.9",

	  bg_color: "[decimal,decimal,decimal] ::
			switch(creature_object.controller,
			       0, if(creature_object.is_land, [0.53, 0.25, 0.31], [0.34, 0.12, 0.16]),
			       1, if(creature_object.is_land, [0.31, 0.25, 0.53], [0.16, 0.12, 0.34]),
			       if(creature_object.is_land, [0.7, 0.8, 0.7], [0.16, 0.12, 0.16]))
	  ",

	  _current_bg_color: { type: "null|[decimal,decimal,decimal]" },
	  _animate_color: { default: false },

	  _updated: { default: true },
	  _dirty: { default: true },

	  _currently_doomed: { default: false },
	  _currently_engaged: { default: false },

	  second_image_texture: { type: "null|texture_object" },
	  have_second_image_texture: "bool :: second_image_texture != null",

	  image_texture: { type: "null|texture_object" },
	  image_texture_dim: "[decimal,decimal] :: if(image_texture != null, [image_texture.width, image_texture.height], [0.0, 0.0])",

	  image_zoom_override: { type: "decimal", default: 0.0, set: "[set(_data, value), set(_dirty, true)]" },

	  image_translate_x: { type: "decimal|null" },
	  image_translate_y: { type: "decimal|null" },
	  image_scale: { type: "decimal|null" },

	  calculate_image_translate_x: "decimal :: image_translate_x or ((adjustments['translate_x'] or 0.0) + (adjustments[if(is_friend,'translate_friend_x','translate_enemy_x')] or 0.0))
			where is_friend = (creature_object.controller = controller.state.nteam)
			where adjustments = lib.citadel.card_adjustments[creature_object.name] or {}",
	  calculate_image_translate_y: "decimal :: image_translate_y or ((adjustments['translate_y'] or 0.0) + (adjustments[if(is_friend,'translate_friend_y','translate_enemy_y')] or 0.0))
			where is_friend = (creature_object.controller = controller.state.nteam)
			where adjustments = lib.citadel.card_adjustments[creature_object.name] or {}",
	  calculate_image_scale: "decimal :: (image_scale or ((adjustments['scale'] or 1.0) * (adjustments[if(is_friend,'scale_friend','scale_enemy')] or 1.0)))
			where is_friend = (creature_object.controller = controller.state.nteam)
			where adjustments = lib.citadel.card_adjustments[creature_object.name] or {}",

	  render_image: "def(int w, int h) ->frame
		lib.gui.render_frame(c, w, h,

		[
			c.save(),

			[
				c.save(),

				c.scale(decimal(w)/decimal(image_dim[0])),
				c.paint_image('images/portraits/card-size/' + portrait),

				c.restore(),

				if(second_portrait != null, [
					c.save(),
					c.rectangle(w*0.5, 0, w, h),
					c.clip(),
					c.scale(decimal(w)/decimal(image_dim[0])),
					c.paint_image('images/portraits/card-size/' + second_portrait),
					c.restore(),
				]),
			]
			where image_dim = c.image_dim('images/portraits/card-size/' + portrait),

			c.restore(),
		]

		)
		 where outline = def(decimal xx, decimal yy, decimal ww, decimal hh)
		[
			c.save(),

			c.translate(xx, yy),

			c.move_to(ww*dir(hex_indent), hh*dir(1)),
			c.line_to(ww*dir(0), hh*dir(0.5)),
			c.line_to(ww*dir(hex_indent), hh*dir(0)),

			c.line_to(ww*dir(hex_indent_inverse), hh*dir(0)),
			c.line_to(ww*dir(1.0), hh*dir(0.5)),
			c.line_to(ww*dir(hex_indent_inverse), hh*dir(1.0)),

			c.line_to(ww*dir(hex_indent), hh*dir(1)),

			c.restore(),
		]
		 where dir = def(decimal a) a
		 where hex_indent_inverse = 1.0 - hex_indent
		 where hex_indent = 0.25*lib.hex.width_from_height(h)/w

		 where c = canvas()
		 where portrait = creature_object.calculate_portrait
		 where second_portrait = creature_object.second_portrait
		 where portrait_x_offset = creature_object.portrait_x_offset*scaling
		 where portrait_y_offset = creature_object.portrait_y_offset*scaling
		 where portrait_scale = creature_object.portrait_scale*scaling
		 where scaling = w/120.0
	  ",

	  render_hud: "def(int w, int h) ->frame
		lib.gui.render_frame(c, w, h,

		[
			c.save(),
			outline(0, 0, w, h),
			c.set_source_rgba(0, 0, 0, 0.01),
			c.fill(),
			c.restore(),

			outline(0, 0, w, h),
			c.set_source_rgba(0, 0, 0, 1),
			c.set_line_width(lib.gui.py(6)),
			c.stroke(),

			outline(w*0.02, h*0.02, w*0.96, h*0.96),
			c.clip(),
			c.new_path(),

			c.save(),

		] +

		if(creature_object.is_land and creature_object.controller != -1, [
			outline(w*0.05, h*0.05, w*0.9, h*0.9),

			if(creature_object.controller = ctrl.state.nteam, c.set_source_rgba(1, 1, 1, 0.5), c.set_source_rgba(0, 0, 0, 1)),
			c.set_line_width(4),
			c.stroke(),
		], []) +

		if(creature_object.is_land = false, [

			c.set_font(lib.font.regular_font),
			c.set_font_size(22*font_scaling),

			c.save(),
			if(creature_object.is_reloading(game_state), c.set_source_rgba(0.5, 0.5, 0.5, 1.0), black_col),
			c.translate(w*0.42 - attack_extents.width/2, h*if(is_enemy, 0.22, 0.922)),
			c.text_path(str(creature_object.attack)),
			c.fill(),
			c.restore(),

			c.save(),
			white_col,
			c.translate(w*0.60 - life_extents.width/2, h*if(is_enemy, 0.22, 0.92)),
			c.text_path(str(displayed_life)),
			c.fill(),
			c.restore(),

			if(displayed_life_shield > 0,
			[
				c.save(),
				white_col,
				c.translate(w*0.69, h*0.92),
				c.set_font(lib.font.bold_font),
				c.set_font_size(9*font_scaling),
				c.text_path(sprintf('%d', displayed_life_shield)),
				c.fill(),
				c.restore(),
			]),
		] where img_dim = c.image_dim(img_path)
		  where img_path = sprintf('images/tile_creature_%s.png', if(creature_object.controller != ctrl.state.nteam, 'silver', 'gold'))
		  where attack_extents = c.text_extents(lib.font.regular_font, 24*font_scaling, str(creature_object.attack))
		  where life_extents = c.text_extents(lib.font.regular_font, 24*font_scaling, str(displayed_life)),


		[]) +

		if(doomed, [
			c.save(),

			c.translate(w*0.3, h*0.2),
			c.set_source_color('white'),
			c.draw_svg(if(ascended, if(ctrl.state.trophies[(creature_object.controller+1)%2][creature_object.loc[0]] > 0, 'images/icons/breach-icon.svg', 'images/icons/breach-no-seal-icon.svg'), 'images/icons/death-icon.svg'), h/2, h/2),

			c.restore(),
			
		], []) +

		map(ability_info[:size(ability_draw_areas)],
		[

			c.save(),
			c.rectangle(0*w, draw_area.rect_offset*h, 1*w, 0.1*h),
			c.clip(),
			c.new_path(),

			outline(0.05*w, 0.05*h, 0.9*w, 0.9*h),
			if(value.is_on_cooldown,
			   c.set_source_rgba(0.5, 0.5, 0.5, _ability_alpha),
			   creature_object.controller = ctrl.state.nteam,
			   c.set_source_rgba(1, 1, 1, _ability_alpha),
			   c.set_source_rgba(0, 0, 0, _ability_alpha)
			),
			c.fill(),

			c.restore(),

			c.save(),
			c.translate(0.5*w - text_area.width*0.5, (draw_area.rect_offset+0.09)*h),
			c.set_font(lib.font.regular_font),
			c.set_font_size(adjusted_font_size),
			c.text_path(value.text),
			if(creature_object.controller = ctrl.state.nteam, c.set_source_rgba(0, 0, 0, _ability_alpha), c.set_source_rgba(1, 1, 1, _ability_alpha)),
			c.fill(),
			c.restore(),

			if(value.is_activated, [
				c.save(),
				outline(left_hex, top_hex, 0.1*w, 0.1*h) where left_hex = 0.5*w - text_area.width*0.5 - 0.1*w where top_hex = draw_area.rect_offset*h,
				if(creature_object.controller = ctrl.state.nteam, c.set_source_rgba(0, 0, 0, _ability_alpha), c.set_source_rgba(1, 1, 1, _ability_alpha)),
				c.fill(),
				c.restore(),

				c.save(),
				c.set_source_rgba(1, 1, 1, 1),
				c.translate(0.5*w - text_area.width*0.5 - 0.07*w, (draw_area.rect_offset+0.09)*h),
				if(creature_object.controller = ctrl.state.nteam, c.set_source_rgba(1, 1, 1, _ability_alpha), c.set_source_rgba(0, 0, 0, _ability_alpha)),
				c.set_font(lib.font.regular_font),
				c.set_font_size(10*font_scaling),
				c.text_path(str(value.cost)),
				c.fill(),

				c.restore(),
			]),

		] 
		  where text_area = c.text_extents(lib.font.regular_font, adjusted_font_size, value.text)
		  where adjusted_font_size = if(text_area_base.width <= available_width, 12*font_scaling, 12*font_scaling*decimal(available_width)/decimal(text_area_base.width))
		  where text_area_base = c.text_extents(lib.font.regular_font, 12*font_scaling, value.text)
		  where available_width = w - w*abs(0.5 - draw_area.rect_offset)*1.2
		  where draw_area = ability_draw_areas[index]
		) //end of abilities map

		+ if(creature_object.energy > 0, [

			outline(w*0.72, h*0.37, w*0.25, h*0.25),
			if(creature_object.controller = ctrl.state.nteam, white_col, black_col),
			c.fill(),

			c.set_font(lib.font.regular_font),
			c.set_font_size(24*font_scaling),

			c.save(),
			c.translate(w*0.79, h*0.57),
			if(creature_object.controller = ctrl.state.nteam, black_col, white_col),
			c.text_path(str(creature_object.energy)),
			c.fill(),
			c.restore(),
		], [
		]) +

		map(filter(creature_object.school, value > 0), [
			c.set_source_color(school_color),
			c.arc(center_x, h*0.5, w*0.05, 0.0, 2*3.15),
			c.fill(),

			c.set_source_color(outline_school_color),
			c.arc(center_x, h*0.5, w*0.05, 0.0, 2*3.15),
			c.set_line_width(w*0.02),
			c.stroke(),
		] where center_x = if(direction_facing = 1, w*0.1 + w*0.1*index, w*0.9 - w*0.1*index)
		  where outline_school_color = [school_color[0]*0.5, school_color[1]*0.5, school_color[2]*0.5]
		  where school_color = lib.citadel.school_info[value].color)

		where ability_draw_areas = if(creature_object.controller = ctrl.state.nteam,
		[
			{
				rect_offset: 0.05,
			},
			{
				rect_offset: 0.2,
			},

			{
				rect_offset: 0.35,
			},
			{
				rect_offset: 0.5,
			},
		
		], [
			{
				rect_offset: 0.85,
			},
			{
				rect_offset: 0.7,
			},
			{
				rect_offset: 0.55,
			},
			{
				rect_offset: 0.4,
			}
		])

		where ability_info = [{text: string, is_activated: bool, cost: int, is_on_cooldown: null|bool}]<-
		if(creature_object.controller = -1, [],
		map(filter(creature_object.abilities, value not in ['Haste']) + creature_object.rules_short +
		    map(filter(creature_object.triggered_abilities, value.hidden_on_creature = false), value.summary) +
		    map(filter(creature_object.passive_abilities, value.hidden_on_creature = false), value.name) +
		 if(creature_object.is_land, [],
		  if(creature_object.armor = 0, [], [str(creature_object.armor) + ' Armor']) +
		  if(creature_object.resistance <= 0, [], [str(creature_object.resistance) + ' Resistance']) +
		  if(creature_object.conduit <= 0, [], [str(creature_object.conduit) + ' Conduit']) +
		  if(creature_object.is_building, ['Building'], [])),
		  {
			text: value,
			is_activated: false,
			cost: 0,
		}) +
		
		map(filter(creature_object.activated_abilities, if(value is class activated_ability, value.hidden_on_creature = false, true)), {
			text: value.name,
			is_activated: true,
			cost: value.cost,
			is_on_cooldown: value.is_on_cooldown,
		}) +
		map(creature_object.status_effects, {
			text: value,
			is_activated: false,
			cost: 0,
		}))

		)

		 where is_enemy = creature_object.controller != ctrl.state.nteam
		 where outline = def(decimal xx, decimal yy, decimal ww, decimal hh)
		[
			c.save(),

			c.translate(xx, yy),

			c.move_to(ww*dir(hex_indent), hh*dir(1)),
			c.line_to(ww*dir(0), hh*dir(0.5)),
			c.line_to(ww*dir(hex_indent), hh*dir(0)),

			c.line_to(ww*dir(hex_indent_inverse), hh*dir(0)),
			c.line_to(ww*dir(1.0), hh*dir(0.5)),
			c.line_to(ww*dir(hex_indent_inverse), hh*dir(1.0)),

			c.line_to(ww*dir(hex_indent), hh*dir(1)),

			c.restore(),
		]

		 where outline_top = def(decimal xx, decimal yy, decimal ww, decimal hh)
		 [
		 	c.save(),
			c.move_to(ww*dir(hex_indent), hh*dir(0)),
			c.line_to(ww*dir(hex_indent*0.4), hh*dir(0.3)),
			c.line_to(ww*dir(1-hex_indent*0.4), hh*dir(0.3)),
			c.line_to(ww*dir(hex_indent_inverse), hh*dir(0)),
			c.restore(),
		 ]

		 where outline_bot = def(decimal xx, decimal yy, decimal ww, decimal hh)
		 [
		 	c.save(),
			c.move_to(ww*dir(hex_indent), hh*dir(1)),
			c.line_to(ww*dir(hex_indent*0.4), hh*dir(0.7)),
			c.line_to(ww*dir(1-hex_indent*0.4), hh*dir(0.7)),
			c.line_to(ww*dir(hex_indent_inverse), hh*dir(1)),
			c.restore(),
		 ]

		 where outline_portrait = def(decimal xx, decimal yy, decimal ww, decimal hh)
		 [
		 	c.save(),
			c.translate(xx, yy),

			c.move_to(ww*dir(hex_indent*0.4), hh*dir(0.7)),
			c.line_to(ww*dir(0), hh*dir(0.5)),
			c.line_to(ww*dir(hex_indent*0.4), hh*dir(0.3)),

			c.line_to(ww*dir(1-hex_indent*0.4), hh*dir(0.3)),
			c.line_to(ww*dir(1.0), hh*dir(0.5)),
			c.line_to(ww*dir(1-hex_indent*0.4), hh*dir(0.7)),

			c.restore(),
		 ]
		 where font_scaling = h/100.0
		 where hex_indent_inverse = 1.0 - hex_indent
		 where hex_indent = 0.25*lib.hex.width_from_height(h)/w
		 where dir = if(direction_facing > 0, def(decimal a) a, def(decimal a) 1.0 - a)
		 where white_col = c.set_source_rgba(1, 1, 1, 1)
		 where black_col = c.set_source_rgba(0, 0, 0, 1)
		 where c = canvas()
		  where portrait = creature_object.calculate_portrait
		  where portrait_x_offset = creature_object.portrait_x_offset*scaling
		  where portrait_y_offset = creature_object.portrait_y_offset*scaling
		  where portrait_scale = creature_object.portrait_scale*scaling
		  where scaling = w/120.0
		  where direction_facing = if(ctrl != null and ctrl.state.nteam = 1, -1, 1) * creature_object.direction_moving
		  where ascended = ctrl.end_of_turn_state != null and doomed and find(ctrl.end_of_turn_state.endzoned_creatures, value = creature_object.summon_id) != null
		  where doomed = (_is_preview = false) and ctrl.end_of_turn_state != null and
		                (creature_object.is_land = false and (future_me = null or future_me.controller != creature_object.controller)
		    where future_me = find(ctrl.end_of_turn_state.creatures, value.summon_id = creature_object.summon_id))
		  where ctrl = controller
	  ",

	  _ability_alpha: { default: 1.0, change: "set(_dirty, true)" },

	  devotion_highlight: {
		type: "bool",
		default: false,
	  },

	  devotion_launch_animation: "def(int nschool) ->commands
	  spawn('devotion_token', {
		school: nschool,
		mid_x: if(direction_facing = 1, int(x + (0.1 + 0.1*n)*img_w), int(x2 - (0.1 + 0.1*n)*img_w)),
		mid_y: mid_y,
		_width: lib.gui.py(12),
		zorder: zorder+1,
	  }, [
	 	child.launch_from_creature_anim(),
	  ])
	   where n = index(creature_object.school, nschool)
	   where direction_facing = if(controller != null and controller.state.nteam = 1, -1, 1) * creature_object.direction_moving
	  ",

	  _tooltip_text: "string ::

		if(creature_object.is_building, 'Building', creature_object.is_land, 'Land', 'Creature' + c.emdash + str(creature_object.attack) + ' Atk, ' + str(creature_object.net_life) + ' Life') + '\n' +


		if(creature.is_land = false and creature_object.armor > 0,
			'Armor' + c.emdash + str(creature_object.armor) + '\n(The first ' + str(creature_object.armor) + ' damage from any attack is prevented)\n', '') +

		if(creature_object.resistance > 0,
			'Resistance' + c.emdash + str(creature_object.resistance) + '\n(Enemy spells cost ' + str(creature_object.resistance) + ' additional mana if they target the tile this ' + if(creature_object.is_land, 'land', 'creature') + ' is in.\n', '') +

		if(creature_object.conduit > 0,
			'Conduit' + c.emdash + str(creature_object.conduit) + '\n(Spells cost ' + str(creature_object.conduit) + ' less mana if the tile this ' + if(creature_object.is_land, 'land', 'creature') + ' is in.\n', '') +

		if(creature.is_land = false and creature.is_building = false and creature.move != 1,
			'Movement' + c.emdash + str(creature_object.move) + '\n(Moves ' + creature.move + ' tiles each turn)\n', '') +


		if(creature.abilities, fold(map(creature.abilities,
			value + if(help_str = null, '', ' (' + str(help_str) + ')' + '\n') where help_str = help[value]
		), a+b), '') +

		if(creature.passive_abilities, fold(map(filter(creature.passive_abilities, value.hidden_on_creature = false),
		value.name + q( <font tag='circle' size='-4'>P</font> &emdash;) + value.rules
		), a+b), '') +

		if(creature.triggered_abilities, fold(map(filter(creature.triggered_abilities, value.hidden_on_creature = false),
		value.name + q( <font tag='circle' size='-4'>T</font> &emdash;) + value.rules
		), a+b), '') +

		creature.rules

		where creature = creature_object
		where help = lib.json.get_document_map('data/help-abilities.cfg')
		where c = canvas()
	  ",

	  _land_flag: { type: "null|obj creature_land_flag", set: "[
	    if(_data, _data.animate_flag_retraction()),
		set(_data, value)
		]"
	  },

	  applied_particle_effects: { type: "{string ->ParticleEffectEntry}", default: {} },

	  set_particle_effects: "def([string] effects) ->commands
	  [
	  	map(applied_particle_effects, ; if(key not in effects, [remove_particle_effect(key), value.obj.fade_away_and_die(), set(applied_particle_effects, remove_from_map(applied_particle_effects, key))])),
		map(effects, ; add_particle_effect(value))
	  ]",

	  add_particle_effect: "def(string name) ->commands
	  if(_in_summoning_animation,
	     schedule(10, ; add_particle_effect(name)),
	  if(_is_preview = false and
	     (not applied_particle_effects[name]) and
		 find(level.chars, value is obj tile) != null, [
		switch(name,
			'rampage',
			  animate(me, {
				_ability_alpha: 0.0,
			  }, {
				duration: 20,
			  }); _start_rampage(),
			
			spawn('particle_controller', {
				_type: name,
				x: mid_x,
				y: mid_y,
				zorder: zorder+100,
				follow_obj: me,
			}, [
				set(applied_particle_effects[name], {obj: child})
			])
		)
	  ])
	  )
	  ",

	  remove_particle_effect: "def(string name) ->commands
	  switch(name,
		'rampage',
			  animate(me, {
				_ability_alpha: 1.0,
			  }, {
				duration: 20,
			  }),
		 
		 set(applied_particle_effects, remove_from_map(applied_particle_effects, name))
	  )
	  ",

	  _start_rampage: "def() ->commands
	  	;

		animate(me, {
			mouseover_focus: 1.0,
			color_adjust_anim: map(color_adjust, value*if(index = 0, 1.4, 1.0)),
		}, {
			name: 'rampage',
			replace_existing: true,
			duration: 16,
			sleep: true,
			easing: lib.math.ease_in_elastic,
		});

		sleep(0.06);

		animate(me, {
			mouseover_focus: 0.0,
			color_adjust_anim: color_adjust,
		}, {
			name: 'rampage',
			replace_existing: true,
			duration: 16,
			sleep: true,
			easing: lib.math.ease_out_elastic,
		});
		sleep(0.1);

		if('rampage' in creature_object.particle_effects, _start_rampage())
	  ",

	  spawn_effect: "def(string effect_name, {string->any} args={}) ->commands
	  spawn(effect_name, {
		target_creature: me,
		targets: [],
	  } + args)
	  ",

		blink_particles: "def() ->commands [
			spawn('particle_controller', {
				_type: 'blink',
				x: mid_x,
				y: mid_y,
				zorder: zorder+100,
			}, [
				animate(child, {
					emission_rate: 0.0,
				}, {
					duration: 10,
					on_complete: schedule(60, remove_object(child)),
				})
			])
		]",
	
		blink_particles_end: "def() ->commands [

		]",
	

	  set_base_tex: "def() ->commands
		set(base_tex, query_cache(lib.gui.image_cache, img_path, get_texture({ image: img_path, surface_flags: ['NO_ALPHA_FILTER', 'NO_CACHE']})))
		  where img_path = sprintf('tile_creature_%s.png', if(creature_object.controller != controller.state.nteam, 'silver', 'gold'))
	  ",

	  base_tex: { type: "null|texture_object", },

	  use_base_tex: "bool :: creature_object.is_land = false",

	  set_tex_mask: "def(string name) ->commands
	  	set(tex_mask, query_cache(lib.gui.image_cache, name, get_texture({ image: name, surface_flags: ['NO_ALPHA_FILTER', 'NO_CACHE']})))
	  ",

	  tex_mask: { type: "null|texture_object", },

	  has_tex_mask: "bool :: tex_mask != null",

	  saturation_adjust: { type: "decimal", default: 0.0 },

	  bright_adjust: { type: "decimal", default: 0.0 },

	  shader_bright: "decimal :: bright_adjust",

	  hue_shift: { type: "decimal", default: 0.0 },

	  target_hue: { type: "decimal", default: 0.0 },
	  target_hue_ratio: { type: "decimal", default: 0.0 },

	  _land_base_controller: { type: "int", default: -1 },

	  create_base: "def() ->commands
	  if(creature_object.is_land and creature_object.controller >= 0 and (land_base = null or creature_object.controller != _land_base_controller), [
		set(_land_base_controller, creature_object.controller),
	  	spawn('image_widget', {
			image: sprintf('tile_land_%s.png', if(creature_object.controller != controller.state.nteam, 'silver', 'gold')),
			image_area: [0,0,400,320],
			draw_width: int(img_w*1.2),
			draw_height: int(img_h*1.2),
			zorder: zorder-1,
			mid_x: mid_x,
			mid_y: mid_y,
			rotate: rotate,
		}, [
			set(land_base, child),
		])
		]
	  )
	  ",

	  land_base: { type: "null|obj image_widget" },
	},

	object_type: [

		{
			id: "missile",
			animation: [
				{
					id: "normal",
					image: "missile.png",
					rect: [0,0,71,71],
					frames: 1,
					duration: 10,
					scale: 1,
				}
			],

			on_end_normal_anim: "die()"
		},

	],

	shader: {
		name: "creature_shader",
		vertex: "
        uniform mat4 u_anura_mvp_matrix;
		uniform float u_property_mid_x;
		uniform float u_property_mid_y;
		uniform float u_property_img_w;
		uniform float u_property_img_h;
		uniform float u_property_scale_x;
		uniform float u_property_scale_y;
		uniform float u_property_scale_rot;
		uniform vec4 u_anura_draw_area;
        attribute vec4 a_anura_vertex;
        attribute vec2 a_anura_texcoord;
        varying vec2 v_texcoord;

		vec2 scale_along_angle(vec2 point, float rotate, float amount) {
				float s = sin(rotate);
				float c = cos(rotate);

				float xc = point.x * c - point.y * s;
				float yc = point.x * s + point.y * c;

				yc *= amount;

				s = sin(-rotate);
				c = cos(-rotate);

				return vec2(xc * c - yc * s, xc * s + yc * c);
		}

		void main()
		{
            v_texcoord = a_anura_texcoord;

			if(u_property_scale_x != 1.0 || u_property_scale_y != 1.0) {

				float rotate = u_property_scale_rot*0.0174533;

				vec2 vertex = a_anura_vertex.xy;

				vertex = scale_along_angle(vertex, rotate, u_property_scale_y);
				vertex = scale_along_angle(vertex, rotate + 90*0.0174533, u_property_scale_x);

            	gl_Position = u_anura_mvp_matrix * vec4(vertex[0], vertex[1], a_anura_vertex[2], a_anura_vertex[3]);
			} else {
	          	gl_Position = u_anura_mvp_matrix * a_anura_vertex;
			}
		}
		",

		fragment: "
		#version 120
		uniform sampler2D u_anura_tex_map;
		uniform sampler2D u_property_image_texture;
		uniform vec2 u_property_image_texture_dim;

		uniform sampler2D u_property_second_image_texture;
		uniform bool u_property_have_second_image_texture;

		uniform float u_property_img_h;
		uniform float u_property_img_w;

		uniform sampler2D u_property_tex_mask;
		uniform sampler2D u_property_base_tex;

		uniform bool u_property_use_base_tex;
		uniform bool u_property_has_tex_mask;
		uniform bool u_property_devotion_highlight;
		uniform float u_property_tex_mask_x_ratio;
		uniform float u_property_tex_mask_y_ratio;
		uniform vec4 u_anura_sprite_area;
		uniform vec4 u_property_color_adjust_anim;
		uniform bool is_flashing;
		uniform float u_property_alpha;
		uniform float u_property_mouseover_focus;
		uniform float u_property_hud_alpha;
		uniform float u_property_size_override;
		uniform float u_property_hue_shift;
		uniform float u_property_saturation_adjust;
		uniform float u_property_shader_bright;
		uniform float u_property_target_hue;
		uniform float u_property_target_hue_ratio;

		uniform float u_property_calculate_image_translate_x;
		uniform float u_property_calculate_image_translate_y;
		uniform float u_property_calculate_image_scale;
		varying vec2 v_texcoord;

		vec3 rgb_to_hsv(vec3 c)
		{
			vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
			vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
			vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));

			float d = q.x - min(q.w, q.y);
			float e = 1.0e-10;
			return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
		}

		vec3 hsv_to_rgb(vec3 c)
		{
			vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
			vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
			return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
		}
		void main()
		{
			vec2 img_uv = vec2(v_texcoord.x, v_texcoord.y * ((u_property_img_h/u_property_img_w)/(u_property_image_texture_dim.y/u_property_image_texture_dim.x)))*u_property_calculate_image_scale + vec2(u_property_calculate_image_translate_x, u_property_calculate_image_translate_y);

			img_uv = mix(img_uv, vec2(0.5, 0.5), u_property_mouseover_focus*0.2);
			vec2 blur_size = vec2(0.5/u_property_image_texture_dim.x, 0.5/u_property_image_texture_dim.y);

			if(!u_property_have_second_image_texture || img_uv.x < 0.45) {
				gl_FragColor = (
					texture2D(u_property_image_texture, img_uv + vec2(blur_size.x, blur_size.y)) +
					texture2D(u_property_image_texture, img_uv + vec2(-blur_size.x, blur_size.y)) +
					texture2D(u_property_image_texture, img_uv + vec2(blur_size.x, -blur_size.y)) +
					texture2D(u_property_image_texture, img_uv + vec2(-blur_size.x, -blur_size.y)) +
					texture2D(u_property_image_texture, img_uv)*2.0
				)/6.0;
			} else if(img_uv.x < 0.55) {
				gl_FragColor = mix(
					texture2D(u_property_image_texture, img_uv),
					texture2D(u_property_second_image_texture, img_uv),
					(img_uv.x - 0.45)*10.0
				);
			} else {
				gl_FragColor = (
					texture2D(u_property_second_image_texture, img_uv + vec2(blur_size.x, blur_size.y)) +
					texture2D(u_property_second_image_texture, img_uv + vec2(-blur_size.x, blur_size.y)) +
					texture2D(u_property_second_image_texture, img_uv + vec2(blur_size.x, -blur_size.y)) +
					texture2D(u_property_second_image_texture, img_uv + vec2(-blur_size.x, -blur_size.y)) +
					texture2D(u_property_second_image_texture, img_uv)*2.0
				)/6.0;
			}

			gl_FragColor[0] = 1.0 - (1.0 - gl_FragColor[0])/u_property_color_adjust_anim[0];
			gl_FragColor[1] = 1.0 - (1.0 - gl_FragColor[1])/u_property_color_adjust_anim[1];
			gl_FragColor[2] = 1.0 - (1.0 - gl_FragColor[2])/u_property_color_adjust_anim[2];
			gl_FragColor[3] = 1.0 - (1.0 - gl_FragColor[3])/u_property_color_adjust_anim[3];

			//If the position is outside of the hex area, set alpha to 0.
			float upos = (v_texcoord[0] - u_anura_sprite_area[0]) / (u_anura_sprite_area[2] - u_anura_sprite_area[0]);
			float vpos = (v_texcoord[1] - u_anura_sprite_area[1]) / (u_anura_sprite_area[3] - u_anura_sprite_area[1]);
			float u_from_side = 0.5 - abs(upos - 0.5);
			float v_from_center = abs(vpos - 0.5);

			if(u_from_side < v_from_center/2.0) {
				gl_FragColor.a = 0.0;
			}

			if(u_property_hue_shift > 0.0) {
				vec3 hsv = rgb_to_hsv(gl_FragColor.rgb);
				hsv.r = mod(hsv.r + u_property_hue_shift, 1.0);
				gl_FragColor.rgb = hsv_to_rgb(hsv);
			}

			if(u_property_target_hue_ratio > 0.0) {
				vec3 hsv = rgb_to_hsv(gl_FragColor.rgb);
				hsv.r = u_property_target_hue;
				vec3 rgb = hsv_to_rgb(hsv);
				gl_FragColor.rgb = mix(gl_FragColor.rgb, rgb, u_property_target_hue_ratio);
			}

			if(u_property_saturation_adjust != 0.0) {
				vec3 hsv = rgb_to_hsv(gl_FragColor.rgb);
				hsv[1] += u_property_saturation_adjust;
				gl_FragColor.rgb = hsv_to_rgb(hsv);
			}

			if(u_property_shader_bright != 0.0) {
				vec3 hsv = rgb_to_hsv(gl_FragColor.rgb);
				hsv[2] += u_property_shader_bright;
				gl_FragColor.rgb = hsv_to_rgb(hsv);
			}

			if(u_property_use_base_tex) {
				vec4 col = texture2D(u_property_base_tex, v_texcoord);
				gl_FragColor.rgb = mix(gl_FragColor.rgb, col.rgb, col.a*u_property_hud_alpha);
				gl_FragColor.a = max(gl_FragColor.a, col.a*u_property_hud_alpha);
			}

			if(u_property_has_tex_mask) {
				vec4 col = texture2D(u_property_tex_mask, v_texcoord);
				gl_FragColor.rgb = mix(gl_FragColor.rgb, col.rgb, col.a);
				gl_FragColor.a = max(gl_FragColor.a, col.a);
			}

			vec4 col = texture2D(u_anura_tex_map, v_texcoord);
			if(col.a > 0.02) {
				if(u_property_devotion_highlight && v_texcoord.y > 0.4 && v_texcoord.y < 0.6 && v_texcoord.x < 0.2) {
					vec3 hsv = rgb_to_hsv(col.rgb);
					hsv[2] += 0.4;
					col.rgb = hsv_to_rgb(hsv);
				}

				gl_FragColor.rgb = mix(gl_FragColor.rgb, col.rgb, col.a*u_property_hud_alpha);
				gl_FragColor.a = max(gl_FragColor.a, col.a*u_property_hud_alpha);

			}

			if(is_flashing) {
				gl_FragColor[0] = gl_FragColor[1] = gl_FragColor[2] = 1.0;
			}

			gl_FragColor.a *= u_property_alpha/255.0;
		}
		",


		create: "[
			set(uniform_commands.is_flashing, false),
		]",
	},

	on_show_tooltip: "
		if(_is_preview = false and creature_object.base_card != null,
		[
			spawn('card', mid_x, mid_y, {
				zorder: lib.citadel.zorder('card_tips'),
				in_hand: false,
				card_size: 0.75,
				alpha: 0,
				ignore_clicks: true,
				card_type: construct('card', creature_object.base_card),
				controller: ctrl,
			}, [
				ctrl.set_tooltip(child, me),
				animate(child, {
					alpha: 255,
					card_size: 2.5,
					mid_x_decimal: decimal(mid_x - lib.gui.px(220)),
				}, {
					duration: 20,
				}),
			]),

		map(creature_object.rules_tips[:size(positions)],
			spawn('tip_dialog', {
				mid_x: positions[index][0],
				mid_y: positions[index][1],
				zorder: zorder+10000,
				_tip: {
					key: 'tip',
					text: value.text,
					targets: [me],
				},

				_title: value.title,
				_has_close: false,
				_width: lib.gui.py(220),
				_height: lib.gui.py(120),
			}, [
				ctrl.append_tooltip(child)
			])
		)

		where positions = [
			[x2 + lib.gui.py(180), top_y + lib.gui.py(140)],
			[x2 + lib.gui.py(180), top_y],
			[x2 + lib.gui.py(180), top_y + lib.gui.py(140)*2],
		]
		where top_y = max(lib.gui.py(80), mid_y - lib.gui.py(140))

		]
		) where ctrl = obj citadel_controller <- arg.controller
	",

	effects: [{
		name: "particle1",
		zorder: 1,
		create: "[
			set(parent.texture, load_texture('images/red-cross.png')),
			set(uniforms.u_tex_map, 1),
			set(uniforms.u_color, [255,255,255,255]),
			set(draw_mode, 'points'),
			
			set(parent.regen_start_position, float_array(flatten(map(range(5), [1d70 - 35, 40 - 1d20])), 2)),
			set(parent.regen_attrib_cycle, float_array(flatten(map(range(5), 1d50)), 1)),
		]",
		
		draw: "[
			bind_texture(parent.texture, 1),
			
			set(uniforms.u_cycle, parent.cycle),
			set(uniforms.u_start_cycle, parent.regen_start_cycle),
			set(uniforms.u_end_cycle, parent.regen_end_cycle),
			set(uniforms.u_centre_position, [parent.mid_x, parent.mid_y]),
			set(attributes.a_position, parent.regen_start_position),
			set(attributes.a_start_cycle, parent.regen_attrib_cycle),
		]",
	}],
}
