{
	id: "library_controller",
	prototype: ["citadel_controller_base"],
	is_human: false,
	is_strict: true,
	always_active: true,
	hidden_in_game: false,

	types: {
		CardEntry: "{
			name: string,
			card: class card,
			num_copies: int,
			obj: null|obj card
		}",
		CardGroup: "{
			entries: [CardEntry],
			name: string,
			icon: null|string,
		}",

		CardFilter: "{
			type: string,
			cmp: string,
			value: string,
		}",
	},

	properties: {
		title_controller: { type: "obj title_controller" },
		return_controller: { type: "custom_obj" },

		font: "lib.font.regular_font",

		//the dimensions we use for our display. Don't use the bottom
		//80 pixels of the screen.
		level_width: "int :: level.dimensions[2] - level.dimensions[0]",
		level_height: "int :: level.dimensions[3] - level.dimensions[1]",

		//the left/right side of the 'usable' area -- i.e. cutting off edges
		//to make for a 4:3 display.
		gui_left_edge: "int :: (level_width - (level_height*4)/3)/2",
		gui_right_edge: "int :: level_width - gui_left_edge",

		px: "def(int pixels) ->int lib.citadel.px(pixels)",
		py: "def(int pixels) ->int lib.citadel.py(pixels)",

		deck_rules: { type: "class deck_rules" },

		specified_deck: { type: "null|[string]" },
		specified_collection: { type: "null|[string]" },

		account_gold: "int :: _mm_client_state.account_info.gold or 0",

		get_collection: "def() -> [string]
		if(specified_collection != null,
		   specified_collection,
		   map(filter(_mm_client_state.account_info.collection, value.name in cards_in_sets), value.name)
		   where cards_in_sets = lib.citadel.get_cards_in_set('core')
		  )",

		max_decks: "int :: 9",

		_decks: {
			variable: false,
			type: "DeckMap",
			get: "DeckMap :: _mm_client_state.account_info.decks",
			set: "[
				set(_mm_client_state.account_info.decks, value);
				_sync_decks(),
			]",
		},

		_sync_decks: "def() ->commands
			tbs_send(object<- mm_client, { type: 'set_decks', decks: _decks, user: _mm_client_state.username })
		",

		get_decks: "def() ->DeckMap _decks",

		_get_next_non_clashing_name: "def(string name) ->string
			if(num, regex_replace(name, '\\(' + str(num) + '\\)$', '(' + str(num+1) + ')'), name + ' (2)')
			where num = if(current_num is [string], int(current_num[0]))
			where current_num = regex_match(name, '.*\\((\\d+)\\)')
		",

		_find_non_clashing_name: "def(string name, DeckMap m) ->string
		if(name not in m, name, _find_non_clashing_name(_get_next_non_clashing_name(name), m))
		",

		get_non_clashing_deck_name: "def(string deck_name, null|string original_deck_name=null) ->string
			lib.citadel.get_non_clashing_deck_name(deck_name, get_decks(), original_deck_name)
		",

		editing_deck: { default: false, set: "[set(_data, value), set(_card_highlighted, null)]" },
		_deck_summary: { type: "null|obj library_deck_summary" },
		_done_editing_button: { type: "null|obj button_controller" },

		_deck_summaries: { type: "[obj library_deck_summary]", default: []},

		_title_deck_summary_ypos: "int :: 0",

		_deck_summary_ypos: "def(int n) ->int
			lib.citadel.py(82) + lib.citadel.py(82)*n
		",

		_spawn_deck_summaries: "def() ->commands
		[
			map(_deck_summaries, remove_object(value)),
			set(_deck_summaries, []),

			map(sort(filter(values(_decks), not value.archived)[:max_decks], [a.creation_time,lower(a.name)] < [b.creation_time,lower(b.name)]),
				bind_command(def() ->commands
				spawn('library_deck_summary', {
					selected: false,
					deck_name: value.name,
					original_deck_name: value.name,
					_controller: me,
					_mm: me,
					x2: gui_right_edge - lib.citadel.py(24),
					y: _deck_summary_ypos(index),
					alpha: 0,
				}, [
					add(_deck_summaries, [child]),
					animate(child, {
						alpha: 255,
					}, {
						duration: 20,
					})
				]))
			);

			_spawn_create_deck()
		];

		//if the library was created with a deck specified to edit, start editing it here.
		if(_force_edit_deck is string, [
			if(summary, ; deck_summary_clicked(summary)) where summary = find(_deck_summaries, value.deck_name = _force_edit_deck),
			set(_force_edit_deck, null),

			//if we have a force deck, set our selected schools to the
			//schools used in the deck.
			if(deck, map(unique_schools, ; select_school_filter(value-1))
			  where unique_schools = unique(sort(fold(map(unique_cards, lib.citadel.create_card(value).school_list), a+b, [])))
			  where unique_cards = unique(sort(deck.cards))
			) where deck = Deck<- _decks[_force_edit_deck]

		])

		",

		_force_edit_deck: { type: "null|string" },

		_active_decks_label: { type: "null|obj label" },

		_spawn_active_decks_label: "def() ->commands
		if(_active_decks_label = null,
			spawn('label', 0, 0, {
				mid_x: gui_right_edge - lib.citadel.py(200),
				mid_y: lib.citadel.py(70),
				_font_size: lib.citadel.py(26),
				_text: ['ACTIVE DECKS'],
			}, [
				set(_active_decks_label, child),
			]),

			_active_decks_label not in level.chars,
			add_object(_active_decks_label) asserting _active_decks_label
		)
		",

		_create_deck: { type: "null|obj library_new_deck" },
		_spawn_create_deck: "def() ->commands

		;

		if(specified_deck = null and _archive_controller = null,
		[
		_spawn_active_decks_label(),

		if(count(values(_decks), not value.archived) >= max_decks, [
			remove_object(_create_deck),
			set(_create_deck, null),
		],

		if(_create_deck = null,
			spawn('library_new_deck', 0, 0, {
				x2: xpos,
				y: ypos,
				_click_handler: me.create_new_deck,
			}, [
				set(me._create_deck, child),
			]),
			animate(_create_deck, {
				x2: xpos,
				y: ypos,
			}, {
				duration: 20,
				name: 'move_about',
				replace_existing: true,
			})
		)
			where xpos = gui_right_edge - lib.citadel.py(24)
			where ypos = _deck_summary_ypos(count(_decks, not value.archived))
		)
		]
		)
		",

		_view: { type: "null|obj library_view_controller" },
		view: "obj library_view_controller<- _view",

		_all_cards: { type: "[CardEntry]", default: [] },
		_visible_cards: { type: "[CardGroup]", default: [] },

		_default_sort: "def([CardEntry] entries) ->[CardEntry]
			sort(entries, [a.card.cost + a.card.loyalty_cost, a.card.cost, a.card.type, a.card.name] < [b.card.cost + b.card.loyalty_cost, b.card.cost, b.card.type, b.card.name])
		",

		_mouse_x: "lib.citadel.mouse_pos(level)[0]",
		_mouse_y: "lib.citadel.mouse_pos(level)[1]",

		_delete_item_button: { type: "obj button_controller|null" },
		_archive_item_button: { type: "obj button_controller|null" },

		cards_widget: { type: "obj scrollable_pane|null" },

		deck: "[obj library_deck_entry] <- if(cards_widget = null, [], map(cards_widget.elements, value.obj))",

		exit_to_titlescreen: "def() ->commands [
			lib.citadel.play_sound(me, 'interface/leave-library'),
			if(editing_deck, done_editing_deck()),
			suspend_preloads(50),

			title_controller.transition_screen(
			; [
				remove_object(title_controller),
				add_object(title_controller);
				title_controller.show_ui()
			],
			false),
		]",

		_archive_controller: { type: "null|obj library_archive_controller" },

		showing_shop: { type: "bool", default: false },

		buy_card: "def(string card_name, int price) ->commands
		[
			tbs_send(object<- mm_client, { type: 'buy_cards', price: price, card_name: card_name }),

			add(find_or_die(_all_cards, value.name = card_name).num_copies, 1),
			add(_mm_client_state.account_info.gold, -price),
		]; [
			update_gold_label(),
			view.refresh_display()
		]",

		_gold_label: { type: "null|obj label" },

		update_gold_label: "def() ->commands
		[
			remove_object(_gold_label),

			spawn('label', {
				x2: gui_right_edge - py(370),
				y: level_height - py(100),
				_font_size: lib.citadel.py(16),
				_text: [str(account_gold) + ' gold'],
			}, [
				set(_gold_label, child),
			]),
			
		]",

		open_shop: "def() ->commands
		execute(me,
		[
		set(showing_shop, true),

		[remove_object(c) | c <- _combos, c.grouping in ['shop','archives']],

		spawn('combo_label', {
			x2: gui_right_edge - py(130),
			y: level_height - py(54),
			_text: 'Close Shop',
			_font_size: py(26),
			grouping: 'shop',
			index: 0,
			click_handler: def(obj combo_label lb) ->commands me.close_shop(),
		}, [
		]),

		update_gold_label(),
		]);
		set_all_cards_visible(_active_filters); refresh_view()
		",

		close_shop: "def() ->commands
		execute(me,
		[
			set(showing_shop, false),

			remove_object(_gold_label),
			set(_gold_label, null),

			remove_object(find(level.chars, value is obj combo_label and value.grouping = 'shop')),

			[add_object(c) | c <- _combos, c not in level.chars],
		]);

		set_all_cards_visible(_active_filters); refresh_view()
		",

		enter_archives: "def() ->commands
		execute(me,
		[
			lib.citadel.play_sound(me, 'interface/enter-vault'),
			suspend_preloads(transition_time*2),
			[[set(c.paused, true), add(c.zorder,10000)] | c <- level.chars, c != me, c.mid_x < gui_right_edge - lib.citadel.py(300)],

			spawn('zoom_effect_controller', 0, 0, {
				source_area: rect,
				dest_area: rect,
				begin_zorder: 5000,
				end_zorder: 30000,
			}, [
				animate(child, {
					dest_area: [rect[0] - (rect[2]-rect[0])*0.2, rect[1] - (rect[3]-rect[1])*0.2, rect[2] + (rect[2]-rect[0])*0.2, rect[3] + (rect[3]-rect[1])*0.2],
					effect_alpha: 0.0,
				}, {
					duration: transition_time,
					on_complete: [remove_object(child), bind_command(_finish_enter_archives)],
				})
			])
			where rect = [decimal(gui_left_edge)/decimal(level_width), 0.0, decimal(gui_right_edge - lib.citadel.py(300))/decimal(level_width), 1.0],
			
		]) where transition_time = 20
		",

		_finish_enter_archives: "def() ->commands
		execute(me,[
			[[set(c.paused, false), add(c.zorder,-10000)] | c <- level.chars, c.paused],

			spawn('combo_label', 0, 0, {
				x2: gui_right_edge - py(20),
				y: level_height - py(54),
				_text: 'Back to Library',
				_font_size: py(26),
				grouping: 'back',
				index: 0,
				click_handler: def(obj combo_label lb) ->commands me.leave_archives(),
			}, [
			]),

			set(me.widgets, []),

			map(_view_type_icons, remove_object(value)),
			map(_school_icons, remove_object(value)),
			map(_type_icons, remove_object(value)),
			map(_combos, remove_object(value)),
			remove_object(_view),
			remove_object(_search_label),
			_show_clear_search_button(false),

			remove_object(_create_deck),
			set(_create_deck, null),

			spawn('library_archive_controller', 0, 0, {
				controller: me,
			}, [
				set(me._archive_controller, child),
			]),

			spawn('zoom_effect_controller', 0, 0, {
				begin_zorder: 500,
				source_area: rect,
				dest_area: [rect[0] + (rect[2]-rect[0])*0.2, rect[1] + (rect[3]-rect[1])*0.2, rect[2] - (rect[2]-rect[0])*0.2, rect[3] - (rect[3]-rect[1])*0.2],
				effect_alpha: 0.0,
			}, [
				animate(child, {
					dest_area: rect,
					effect_alpha: 1.0,
				}, {
					duration: transition_time,
					on_complete: remove_object(child),
				})
			])
			where rect = [decimal(gui_left_edge)/decimal(level_width), 0.0, decimal(gui_right_edge - lib.citadel.py(300))/decimal(level_width), 1.0],
		
		]) where transition_time = 20",

		leave_archives: "def() ->commands
		execute(me,
		[
			remove_object(_archive_controller),
			set(_archive_controller, null),

			_add_widgets(),
			[remove_object(c) | c <- level.chars, c is obj combo_label],
			map(_combos, add_object(value)),
			map(_view_type_icons, add_object(value)),
			map(_school_icons, add_object(value));
			map(_type_icons, add_object(value));
			if(_search_label, add_object(_search_label)),
			_select_view_type(obj game_icon<- _mouseover_view_type_icon_selected),
			_spawn_create_deck(),
		])",

		_play_card_add_sound: "def() ->commands
		[
			lib.citadel.play_sound(me, 'interface/card-add')
		]
		",

		play_card_remove_sound: "def() ->commands
		[
			lib.citadel.play_sound(me, 'interface/card-remove')
		]",

		_focus_card: { type: "null|obj card" },
		_focus_card_restore: { type: "null|map" },

		_focus_card_flavor: { type: "null|obj text_area" },

		card_right_clicked: "def(obj card card) ->commands
		if(card = _focus_card,
		[
			card.clear_card_tips(),
			remove_object(find(level.chars, value is obj blur_controller)),
			remove_object(_focus_card_flavor),
			set(_focus_card, null),
			set(_focus_card_flavor, null),
			animate(card, map<- _focus_card_restore, {
				duration: 20,
				name: 'focus',
				on_complete: add(card.zorder, -10000),
			}),

			[set(c.paused, false) | c <- level.chars],
		],

		(not card.animated_movements) and card in (list<- _card_cache.enumerate) and not _focus_card and (find(level.chars, value is obj card and ('focus' in value.animated_movements)) = null),
		[
			
			set(_focus_card, card),
			[set(c.paused, true) | c <- level.chars, c not in [card,me]],
			spawn('blur_controller', 0, 0, {
				begin_zorder: -10000,
				end_zorder: 5000,
				blur_darken: 0.4,
			}, [
			]),

			add(card.zorder, 10000),
			set(_focus_card_restore, { mid_x: card.mid_x, mid_y: card.mid_y, card_size: card.card_size }),
			animate(card, {
				mid_x: level_width/2,
				mid_y: level_height/2,
				card_size: 3.0,
			}, {
				duration: 20,
				name: 'focus',
				on_complete: bind_command(card.show_card_tips),
			}),

			if(card.card_type.flavor_text,
				spawn('text_area', 0, 0, {
					_text: q(<font align='left' size=') + str(lib.citadel.py(22)) + q('>) + card.card_type.flavor_text + q(</font>),
					text_width: lib.citadel.py(600),
					border: lib.citadel.py(8),
					bg_color: [0.2,0.2,0.2,1.0],
					zorder: 10000,
					mid_x: level_width/2,
					mid_y: lib.citadel.py(800),
				}, [
					set(_focus_card_flavor, child),
				])
			)
		])",

		card_clicked: "def(obj card card) ->commands
		if(card = _focus_card or not editing_deck, card_right_clicked(card),
		editing_deck,
		if(deck_rules.max_cards = null or num_cards < deck_rules.max_cards,
		[
			add_deck_item(card.card_type)
		],

		//we can't add more cards to the deck.
		[
			if(_deck_summary,
				_deck_summary.pulse_card_limit()
			)
		])
		where num_cards = sum(map(deck, value.count))
		);
		
		mouseover_card(card.card_type)",

		remove_deck_prompt: "def(null|obj library_deck_summary summary, string deck_name) ->commands
		[
			if(summary, [leave_deck_summary(summary), set(summary.highlighted, false)]),
			object('modal_message_dialog', 0, 0, {
				message: 'Really delete this deck? It will be gone forever.',
				buttons: [{
					text: 'Delete',
					callback: (def()->commands remove_deck(summary, deck_name)),
				}, {
					text: 'Cancel',
					callback: (def()->commands null),
				}],

				_exclude_from_pause: [title_controller],
			}).show_dialog()
		]
		",

		remove_deck: "def(null|obj library_deck_summary summary, string deck_name) ->commands
		execute(me,
		[
			if(_delete_item_button, [
				remove_object(_delete_item_button),
				set(_delete_item_button, null),
			]),

			if(_archive_item_button, [
				remove_object(_archive_item_button),
				set(_archive_item_button, null),
			]),

			set(_deck_summaries, new_deck_summaries),

			remove_object(summary),

			map(new_deck_summaries,
				animate(value, {
					y: _deck_summary_ypos(index),
				}, {
					name: 'animate_removal',
					replace_existing: false,
					duration: 20,
				})
			),

			set(_decks, remove_from_map(_decks, deck.name));
			_sync_decks(),

			if(_archive_controller, [
				remove_object(_archive_controller),
				spawn('library_archive_controller', 0, 0, {
					controller: me,
				}, [
					set(me._archive_controller, child),
				]),
			]),
		]; _spawn_create_deck()
		)
		where deck = Deck<- _decks[deck_name]
		where new_deck_summaries = filter(_deck_summaries, value != summary)
		",

		archive_deck: "def(obj library_deck_summary summary) ->commands
		execute(me,
		[
			if(_delete_item_button, [
				remove_object(_delete_item_button),
				set(_delete_item_button, null),
			]),

			if(_archive_item_button, [
				remove_object(_archive_item_button),
				set(_archive_item_button, null),
			]),

			set(_deck_summaries, new_deck_summaries),

			animate(summary,
			{
				mid_x: gui_right_edge - lib.citadel.py(10),
				mid_y: level_height - lib.citadel.py(10),
				alpha: 0,
			},
			{
				duration: 10,
				on_complete: remove_object(summary),
			}
			),

			map(new_deck_summaries,
				animate(value, {
					y: _deck_summary_ypos(index),
				}, {
					name: 'animate_removal',
					replace_existing: false,
					duration: 20,
				})
			),

			set(deck.archived, true);
			_sync_decks()
		]; _spawn_create_deck()
		)
		where deck = Deck<- _decks[summary.deck_name]
		where new_deck_summaries = filter(_deck_summaries, value != summary)
		",

		enter_deck_summary: "def(obj library_deck_summary summary) ->commands
		[
			if(_delete_item_button, remove_object(_delete_item_button)),
			if(_archive_item_button, remove_object(_archive_item_button)),
			spawn('button_controller', 0, 0, {
				text: 'X',
				tooltip: 'Delete deck',
				zorder: 1000,
				x: summary.x2 - py(64),
				y: summary.y + py(2),
				button_width: py(24),
				button_height: py(24),
				on_click: (def()->commands remove_deck_prompt(summary, summary.deck_name)),
				use_absolute_screen_coordinates: true,
				user_info: summary,
				color_scheme: lib.citadel.library_color_scheme,
			}, [
				set(_delete_item_button, child),
			]),

			spawn('button_controller', 0, 0, {
				text: 'V',
				tooltip: 'Archive deck',
				zorder: 1000,
				x: summary.x2 - py(88),
				y: summary.y + py(2),
				button_width: py(24),
				button_height: py(24),
				on_click: (def()->commands archive_deck(summary)),
				use_absolute_screen_coordinates: true,
				user_info: summary,
				color_scheme: lib.citadel.library_color_scheme,
			}, [
				set(_archive_item_button, child),
			])
		]",

		leave_deck_summary: "def(obj library_deck_summary summary) ->commands
		[
			if(_delete_item_button != null and _delete_item_button.user_info = summary, [
				remove_object(_delete_item_button),
				set(_delete_item_button, null)
			]),
			if(_archive_item_button != null and _archive_item_button.user_info = summary, [
				remove_object(_archive_item_button),
				set(_archive_item_button, null)
			])
		]",

		create_new_deck: "def() ->commands execute(me, [
			spawn('library_deck_summary', 0, 0, {
				selected: false,
				deck_name: deck_name,
				_controller: me,
				_mm: me,
				x2: gui_right_edge - lib.citadel.py(24),
				y: _deck_summary_ypos(count(level.chars, value is obj library_deck_summary)),
			}, [
				add(_deck_summaries, [child]);
				deck_summary_clicked(child)
			])
		]
		where deck_name = find_or_die(map(range(100), 'New Deck ' + str(value+1)), _decks[value] = null))",

		return_deck_from_archive: "def(Deck deck) ->commands execute(me, [
			set(_decks, _decks + {(deck.name): deck}),
			spawn('library_deck_summary', 0, 0, {
				alpha: 0,
				selected: false,
				deck_name: deck.name,
				_controller: me,
				_mm: me,
				x2: gui_right_edge - lib.citadel.py(24),
				y: _deck_summary_ypos(count(level.chars, value is obj library_deck_summary)),
			}, [
				add(_deck_summaries, [child]),
				animate(child, {
					alpha: 255,
				}, {
					duration: 10,
				})
			]),
		])",

		deck_summary_clicked: "def(obj library_deck_summary summary) ->commands
		execute(me,
		if(editing_deck = false,
		execute(me, [
			leave_deck_summary(summary),
			set(summary.highlighted, false),
			set(editing_deck, true),
			fire_event(summary, 'render'),
			remove_object(find(_combos, value.grouping = 'archives')),
			map(_deck_summaries, if(value != summary, remove_object(value))),
			set(_deck_summary, summary),

			animate(summary, {
				y: _title_deck_summary_ypos,
			}, {
				duration: 20,
			}),

			spawn('button_controller', 0, 0, {
				mid_x: gui_right_edge - lib.citadel.py(60),
				mid_y: lib.citadel.py(800),
				text: 'Done',
				on_click: me.done_editing_deck,
			}, [
				set(me._done_editing_button, child),
			]),

			remove_object(_create_deck),
			set(_create_deck, null),
			remove_object(_active_decks_label),

			_create_deck_widget(map(unique_cards, {card_name: value, count: count(deck.cards, value = context.value)} ))
			  where unique_cards = unique(sort(deck.cards))
			  where deck = Deck<- (account_info.decks[summary.deck_name] or {cards: [], name: summary.deck_name, schools: [] }),

			; view.start_editing_deck(),
		])
		)
		)",
		
		done_editing_deck: "def() ->commands execute(me, [
			lib.citadel.play_sound(me, 'interface/done-editing-deck'),
			remove_object(cards_widget),
			set(cards_widget, null),

			if(not deck, [
				remove_object(_deck_summary),
				set(_deck_summaries, filter(_deck_summaries, value != _deck_summary)),
			]),

			if(obj, add_object(obj)) where obj = find(_combos, value.grouping = 'archives'),

			set(editing_deck, false),

			if(_deck_summary, schedule(2, fire_event(_deck_summary, 'render'))),
			set(_deck_summary, null),

			remove_object(_done_editing_button),
			set(_done_editing_button, null),

			map(_deck_summaries, [
				if(value not in level.chars, add_object(value)),
				animate(value, {
					y: _deck_summary_ypos(index)
				}, {
					duration: 20,
				})
			]),

			set(_decks, if(new_deck.cards, old_decks + {(new_deck.name): new_deck}, remove_from_map(old_decks, new_deck.name)))
			  where new_deck = {
					name: summary.deck_name,
					schools: [],
					cards: fold(map(deck, [value.card.name]*value.count), a+b) or [],
					creation_time: if(existing_deck, existing_deck.creation_time, time().unix),
					mod_time: time().unix,
					avatar: summary.avatar,
					archived: false,
				}
			  where existing_deck = account_info.decks[summary.deck_name]
		  where old_decks = remove_from_map(account_info.decks, summary.original_deck_name or summary.deck_name),

			; view.end_editing_deck(),

		]; _spawn_create_deck()) where summary = find_or_die(level.chars, value is obj library_deck_summary)
		",

		_spawn_specified_deck: "def([string] specified_deck) ->commands
		[
		(set(editing_deck, true);
		view.start_editing_deck()),
		_create_deck_widget(entries)
		]
		where entries = map(unique(sort(specified_deck)), {card_name: value, count: count(specified_deck, value = context.value)})
		",

		_create_deck_widget: "def([{card_name: string, count: int}] cards) ->commands [
			remove_object(cards_widget),

			spawn('scrollable_pane', 0, 0, {
				x: gui_right_edge - lib.citadel.py(290),
				y: lib.citadel.py(78),
				area_width: lib.citadel.py(290),
				area_height: lib.citadel.py(680),
				left_align: false,
				step_size: lib.citadel.py(36),

				elements: map(ordered_cards, {
					ypos: lib.citadel.py(36)*index,
					obj: object('library_deck_entry', 0, 0, {
						card: class card<- card_map[value.card_name],
						count: value.count,
						controller: me,
						_delay_drawing_frames: level.cycle + index + 1,
					})
				}),
			}, [
				set(me.cards_widget, child)
			]);

			map(filter(level.chars, value is obj library_deck_entry), [
				set(value.alpha, 0),
				animate(value, {
					alpha: 0,
				}, {
					duration: index,
					name: 'fade_in',
					replace_existing: false,
				}),
				animate(value, {
					alpha: 196,
				}, {
					duration: 20,
					name: 'fade_in',
					replace_existing: false,
				}),
			]),
		]
		where ordered_cards = sort(cards, [card_a.cost, card_a.name] < [card_b.cost, card_b.name] where card_a = class card<- card_map[a.card_name] where card_b = class card<- card_map[b.card_name])
		where card_map = fold(map(cards, {(value.card_name): lib.citadel.create_card(value.card_name)}), a+b, {})",

		add_deck_item: "def(class card_base card) -> commands
		[
		_play_card_add_sound(),
		if(_deck_summary and _deck_summary.avatar = null and card is class card and card.artist,
			set(_deck_summary.avatar_override, card.name); _deck_summary.show_avatar()
		),

		if(entry != null and entry.count < deck_rules.max_duplicates and entry.count < count(account_info.collection, value.name = card.name) and (deck_rules.max_cards = null or num_cards < deck_rules.max_cards),

		[
			(add(entry.count, 1); [entry.render_entry(), view.update_card_quantity(card.name)]),
			entry.pulse(),
		],

		if(entry = null and cards_widget != null,
		[
			let old_elements = map(cards_widget.elements, {obj: value.obj, ypos: value.ypos});
			[
			[
				add(s.ypos, (obj library_deck_entry<- s.obj).area.height)
				| s <- cards_widget.elements, s.ypos >= ypos
			],

			set(cards_widget.elements, cards_widget.elements[:insert_index] + [{ypos: ypos, obj: new_obj}] + cards_widget.elements[insert_index:]),
			];

			cards_widget.recalculate();
			cards_widget.animate_element_movement_from_previous_position(old_elements, 20);
			set(new_obj.alpha, 0);
			new_obj.pulse()
		]; view.update_card_quantity(card.name)
		)
		where ypos = lib.citadel.py(36)*insert_index
		where insert_index = if(insert_before, index(deck, insert_before), size(deck))
		where insert_before = find(deck, [card.cost, card.name] < [value.card.cost, value.card.name])
		where new_obj = object('library_deck_entry', 0, 0, {
			card: card,
			count: 1,
			controller: me,
		})
		) where num_cards = sum(map(deck, value.count))
		]
		where entry = find(deck, value.card.name = card.name)
		",

		remove_deck_item: "def(class card card) -> commands
		if(entry != null and cards_widget != null,
		execute(me,
		[
			play_card_remove_sound(),

			remove_object(entry),
			
			let old_elements = map(cards_widget.elements, {obj: value.obj, ypos: value.ypos});
			[
			[
				add(s.ypos, - (obj library_deck_entry<- s.obj).area.height)
				| s <- cards_widget.elements, s.ypos > item.ypos
			],

			set(cards_widget.elements, filter(cards_widget.elements, value.obj != entry)),

			];

			cards_widget.recalculate();
			cards_widget.animate_element_movement_from_previous_position(old_elements, 20)
		]; view.update_card_quantity(card.name)
		)
		where item = find_or_die(cards_widget.elements, value.obj = entry)
		)
		where entry = find_or_die(deck, value.card.name = card.name)
		",

		num_cards_in_deck: "def(string card_name) ->int|null
		if(editing_deck = false, null,
			if(entry != null, entry.count, 0)
			where entry = find(deck, value.card.name = card_name)
		)
		",

		refresh_view: "def() ->commands view.set_visible_cards(_visible_cards)",

		set_card_preloads: "def([class card] cards) ->commands [
			set(_card_preloads, filter(cards, find(existing, value.card_type = context.value) = null))
		] where existing = [obj card]<- _card_cache.enumerate",

		suspend_preloads: "def(int ncycles) ->commands
			set(_card_preloads_suspended, max(_card_preloads_suspended, cycle+ncycles))
		",
		_card_preloads_suspended: { default: 0 },
		_process_card_preloads: "def() ->commands
		if(_card_preloads_suspended <= cycle and _card_preloads, [
			if(create_card(_card_preloads[0]) != null,
			   set(_card_preloads, _card_preloads[1:])),
		])
		",

		_card_preloads: { type: "[class card]", default: [] },

		_card_cache: { type: "object", init: "create_cache()" },

		create_card: "def(class card card) ->obj card
		query_cache(_card_cache, card,
			object('card', 0, 0, {
				card_type: card,
				controller: me,
				in_hand: false,
				allow_drag: false,
				card_size: 1.5,
				show_shadow: false,
				use_absolute_screen_coordinates: true,
				search_string: _search_terms,
				mouse_enter_handler: bind(me.mouseover_card, card),
				mouse_leave_handler: bind(me.mouseoff_card, card),
			})
		)
		",

		_card_highlighted: {
			type: "null|obj card",
			set: "if(_data != value, [if(_data, _data.hide_halo()), if(value, value.show_halo()), set(_data, value)])",
		},

		mouseover_card: "def(class card_base card) ->commands
		if(editing_deck and obj != null and entry != null and deck_quantity < min(deck_rules.max_duplicates, entry.num_copies),
		   set(_card_highlighted, obj),
		   set(_card_highlighted, null))
			where obj = find(level.chars, value is obj card and value.card_type = card)
			where entry = find(_all_cards, value.name = card.name)
			where deck_quantity = if(deck_item, deck_item.count, 0)
			where deck_item = find(deck, value.card.name = card.name)
		",

		mouseoff_card: "def(class card card) ->commands
		if(obj = _card_highlighted, set(_card_highlighted, null))
			where obj = find(level.chars, value is obj card and value.card_type = card)
		",

		_active_filters: { type: "[CardFilter]", default: [] },

		set_all_cards_visible: "def([CardFilter] filters=[]) ->commands
		set(_visible_cards, map(filter(range(1,6), school_in_filter(value)), {
			name: string<- ENGLISH_SCHOOL_NAMES[value],
			icon: 'school-' + (string<- SCHOOL_NAMES[value]) + '.svg',
			entries: _default_sort(filter(_all_cards, type_in_filter(value.card) and (value.num_copies > 0 or showing_shop) and value.card.first_school = context.value and find(filters, _matches_filter(value, context.value.card) = false) = null))
		}))
		",

		_search_terms: { type: "null|[string]", set: "[set(_data, value), map(cards, set(value.search_string, context.value)) where cards = [obj card]<- _card_cache.enumerate]" },

		_type_icons: { type: "[obj game_icon]", default: [] },
		_type_filter: { type: "[string]", default: [] },
		_type_names: "[string] :: ['creature', 'spell', 'land']",

		_school_icons: { type: "[obj game_icon]", default: [] },
		_school_filter: { type: "[int]", default: [] },

		school_in_filter: "def(int nschool) ->bool (_school_filter = []) or ((nschool-1) in _school_filter)",

		select_school_filter: "def(int num) ->commands
		(
		[
			set(_school_filter, new_filter),
			map(_school_icons, set(value.brightness, if(new_filter = [] or index in new_filter, 255, 64))),
		]
		//if shift is held we add to the existing filter,
		//otherwise replace the filter.
		where new_filter = [int] :: if(num in _school_filter, filter(_school_filter, num != value), if(level.player_info.ctrl_mod_key in [1,2], _school_filter, []) + [num])
		) ; if(_text_entry.text != '' and _active_filters = [], set(_text_entry.text, ''));
		    set_all_cards_visible(_active_filters); refresh_view()
		",

		type_in_filter: "def(class card card) ->bool (_type_filter = []) or (if(card.creature_object, if(card.creature_object.is_construct, 'land', 'creature'), 'spell') in _type_filter)",

		select_type_filter: "def(string type) ->commands
		(
		[
			set(_type_filter, new_filter),
			map(_type_icons, set(value.brightness, if(new_filter = [] or _type_names[index] in new_filter, 255, 64))),
		]
		where new_filter = [string] :: if(type in _type_filter, filter(_type_filter, type != value), if(level.player_info.ctrl_mod_key in [1,2], _type_filter, []) + [type])
		) ; if(_text_entry.text != '' and _active_filters = [], set(_text_entry.text, ''));
		    set_all_cards_visible(_active_filters); refresh_view()
		",


		_text_entry: "text_editor_widget<- widgets.search_entry",

		_view_type_icons: { type: "[obj game_icon]", default: [] },
		_mouseover_view_type_icon_selected: {
			type: "null|obj game_icon",
			set: "if(value != _data, [
				if(_data != null and _data != _mouseover_view_type_icon,
					animate(_data, {
						red: 160,
						green: 160,
						blue: 196,
					}, {
						duration: 10
					})
				),
				set(_data, value),
				if(value != null,
					animate(value, {
						red: 255,
						green: 255,
						blue: 255,
					}, {
						duration: 10
					})
				),
			])",
		},
		_mouseover_view_type_icon: {
			type: "null|obj game_icon",
			set: "if(value != _data, [
				if(_data != null and _data != _mouseover_view_type_icon_selected,
					animate(_data, {
						red: 160,
						green: 160,
						blue: 196,
					}, {
						duration: 10
					})
				),
				set(_data, value),
				if(value != null,
					animate(value, {
						red: 255,
						green: 255,
						blue: 255,
					}, {
						duration: 10
					})
				),
			])"
		},

		_mouse_enter_view_type_icon: "def(obj game_icon icon) ->commands set(_mouseover_view_type_icon, icon)",
		_mouse_leave_view_type_icon: "def(obj game_icon icon) ->commands if(_mouseover_view_type_icon = icon, set(_mouseover_view_type_icon, null))",

		_reset_cached_cards: "def() ->commands
		map(cards, [
			set(value.alpha, 255),
			set(value.clip_area, null),
		])
		 where cards = [obj card]<- _card_cache.enumerate
		",

		_select_view_type: "def(obj game_icon icon) ->commands
		[
			set(_mouseover_view_type_icon_selected, icon),

			set(lib.citadel.preferences, lib.citadel.preferences + {library_view: icon.user_info}),

			_reset_cached_cards(),

			remove_object(_view),

			spawn('library_' + (string<- icon.user_info) + '_controller', 0, 0, {
				x: 0, y: 0,
				controller: me,
			}, [
				set(_view, obj library_view_controller<- child),
			]); refresh_view()
		]",

		_select_default_view: "def() ->commands
		_select_view_type(find_or_die(level.chars, value is obj game_icon and value.user_info = lib_view_type))
			where lib_view_type = lib.citadel.preferences['library_view'] or 'book_view'
		",

		_keys_pressed: "[string] ::
			if(level.player.ctrl_up, ['up'], []) +
			if(level.player.ctrl_down, ['down'], []) +
			if(level.player.ctrl_left, ['left'], []) +
			if(level.player.ctrl_right, ['right'], [])",

		_last_keys_pressed: { type: "[string]|null" },
		_key_just_pressed: "def(string key, [string] pressed) ->bool
			((key in pressed) and (key not in _last_keys_pressed)) or
			streak > 30 and streak%6 = 0
			where streak = (_key_press_streak[key] or 0)
		",

		_key_press_streak: { type: "{string -> int}", default: {} },

		_combos: { type: "[obj combo_label]", default: [] },

		_search_label: { type: "obj label|null" },

		_clear_search_button: { type: "null|obj button_controller" },

		_show_clear_search_button: "def(bool value) ->commands
		if(value,
		if(_clear_search_button,
		   if(_clear_search_button not in level.chars, add_object(_clear_search_button)),
		   spawn('button_controller', 0, 0, {
			x: gui_left_edge + lib.citadel.py(614),
			y: level_height - lib.citadel.py(46),
			button_width: lib.citadel.py(40),
			button_height: lib.citadel.py(20),
			text: 'Clear',
			_font_size: lib.citadel.py(12),
			on_click: me._clear_search,
			color_scheme: lib.citadel.library_color_scheme,
		   }, [
		   	set(me._clear_search_button, child),
		   ])
		),
		remove_object(_clear_search_button)
		)
		",

		_clear_search: "def() ->commands
		if(search_entry != null, [
			set(search_entry.text, ''),
			if(_search_label != null and find(level.chars, value = _search_label) = null,
				add_object(_search_label)
			),
		])
			where search_entry = null|text_editor_widget<- widgets.search_entry
		",

		_add_widgets: "def() ->commands [
		spawn('label', 0, 0, {
			zorder: 50,
			x: gui_left_edge + lib.citadel.py(455),
			y: level_height - lib.citadel.py(55),
			_font_size: lib.citadel.py(18),
			_text: ['Search'],
		}, [
			set(me._search_label, child),
		]),

		set_widgets([
		{
			type: 'text_editor',
			id: 'search_entry',
			x: gui_left_edge + lib.citadel.py(450),
			y: level_height - lib.citadel.py(36),
			font_size: lib.citadel.py(16),
			clear_on_focus: true,
			width: lib.citadel.py(180),
			bg_color: [0.1, 0.1, 0.1],
			no_border: true,
			on_change: q(fire_event('search_changed')),
			on_change_focus: q(fire_event('search_focus')),
		}]),
		]",

		_matches_filter: "def(CardFilter f, class card card) ->bool
		if(f.type = 'type', strstr(lower(card.type_text), f.value) != 0,
		   f.type = 'artist', card.get_artist != null and strstr(lower(card.get_artist.name), f.value) != 0,
		false
		)
		",

		_parse_filter: "def(string s) ->CardFilter|null
		{
			type: values[0],
			cmp: values[1],
			value: values[2],
		}
			where values = [string]<- regex_match(s, '^(.*)([:=<>])(.*)$')
		",
	},

	on_construct: "[]",

	on_create: "execute_instrumented(me, 'create', [
		set(x,0),
		set(y,0),
		set(alpha, 0),

		set(_combos, []),

		spawn('combo_label', 0, 0, {
			x: gui_left_edge + py(14),
			y: level_height - py(54),
			_text: 'Main Menu',
			_font_size: py(26),
			left_rect: lib.citadel.py(-4),
			right_rect: lib.citadel.py(2),
			grouping: 'back',
			index: 0,
			click_handler: def(obj combo_label lb) ->commands me.exit_to_titlescreen(),
		}, [
			add(me._combos, [child]),
		]),

		spawn('combo_label', 0, 0, {
			x2: gui_right_edge - py(130),
			y: level_height - py(54),
			_text: 'Shop',
			_font_size: py(26),
			grouping: 'shop',
			index: 0,
			click_handler: def(obj combo_label lb) ->commands me.open_shop(),
		}, [
			add(me._combos, [child]),
		]),

		spawn('combo_label', 0, 0, {
			x2: gui_right_edge - py(20),
			y: level_height - py(54),
			_text: 'Vault',
			_font_size: py(26),
			grouping: 'archives',
			index: 0,
			click_handler: def(obj combo_label lb) ->commands me.enter_archives(),
		}, [
			add(me._combos, [child]),
		]),

		map(range(1,6), spawn('game_icon', gui_left_edge + lib.citadel.py(190) + lib.citadel.py(50)*index, level_height - lib.citadel.py(34), {
			icon: 'school-' + (string<- SCHOOL_NAMES[value]) + '.svg',
			force_no_alpha: true,
			size: lib.citadel.py(48),
			click_handler: def(obj game_icon icon) ->commands select_school_filter(index),
			mouse_enter_handler: def(obj game_icon icon) ->commands set(icon.brightness, 512),
			mouse_leave_handler: def(obj game_icon icon) ->commands set(icon.brightness, if(_school_filter = [] or index in _school_filter, 255, 64)),
			use_absolute_screen_coordinates: true,
		}, [
			add(_school_icons, [child])
		])),

		map(_type_names, spawn('game_icon', gui_left_edge + lib.citadel.py(480) + lib.citadel.py(40)*index, level_height - lib.citadel.py(64), {
			icon: ['type-creature.svg', 'type-spell.svg', 'type-land.svg'][index],
			size: lib.citadel.py(38),
			force_no_alpha: true,
			click_handler: def(obj game_icon icon) ->commands select_type_filter(_type_names[index]),
			mouse_enter_handler: def(obj game_icon icon) ->commands set(icon.brightness, 512),
			mouse_leave_handler: def(obj game_icon icon) ->commands set(icon.brightness, if(_type_filter = [] or (_type_names[index] in _type_filter), 255, 64)),
			use_absolute_screen_coordinates: true,
		}, [
			add(_type_icons, [child])
		])),

		_add_widgets(),

		set(_all_cards, collection_items);
		set_all_cards_visible();

		set(_view_type_icons, []),

		spawn('game_icon', 0, 0, {
			mid_x: gui_left_edge + lib.citadel.py(840),
			mid_y: lib.citadel.py(870),
			icon: 'open-book.svg',
			size: lib.citadel.py(34),
			force_no_alpha: true,
			red: 160, green: 160, blue: 196,
			user_info: 'book_view',

			mouse_enter_handler: me._mouse_enter_view_type_icon,
			mouse_leave_handler: me._mouse_leave_view_type_icon,
			click_handler: me._select_view_type,
			use_absolute_screen_coordinates: true,
		}, [
			add(_view_type_icons, [child]),
		]
		),

		spawn('game_icon', 0, 0, {
			mid_x: gui_left_edge + lib.citadel.py(890),
			mid_y: lib.citadel.py(870),
			icon: 'library-grid.svg',
			size: lib.citadel.py(34),
			force_no_alpha: true,
			red: 160, green: 160, blue: 196,
			user_info: 'scroll_view',

			mouse_enter_handler: me._mouse_enter_view_type_icon,
			mouse_leave_handler: me._mouse_leave_view_type_icon,
			click_handler: me._select_view_type,
			use_absolute_screen_coordinates: true,
		}, [
			add(_view_type_icons, [child]),
		]
		); _select_default_view(),

		if(specified_deck, _spawn_specified_deck(specified_deck), _spawn_deck_summaries()),
	]) where collection_items = sort(map(sort(lib.citadel.get_cards_in_set('core')), {name: value, num_copies: count(collection, value = context.value), card: lib.citadel.create_card(value)}), a.name < b.name)
	  where collection = get_collection()",

	on_process: "[
		_process_card_preloads(),

		if(_view != null, [

			if(_key_just_pressed('up', pressed), _view.scroll_up()),
			if(_key_just_pressed('down', pressed), _view.scroll_down()),
			if(_key_just_pressed('left', pressed), _view.scroll_left()),
			if(_key_just_pressed('right', pressed), _view.scroll_right()),

			map(pressed, set(_key_press_streak[value], (_key_press_streak[value] or 0)+1));
			[set(_key_press_streak[k], 0) | k <- keys(_key_press_streak), k not in pressed],
		]),

		set(_last_keys_pressed, pressed),
	] where pressed = _keys_pressed",

	"on_mouse_down*": "
	if(_focus_card, card_right_clicked(_focus_card))
	",

	on_ctrl_up: "debug('CONTROL UP')",
/*
	on_window_resize: "[
		set(level.dimensions, [0,0,new_width,new_height]),
		fire_event('dimensions_updated'),
	] where new_width = max(int<- arg.width,800)-1
	  where new_height = max(int<- arg.height, 600)-1",
*/	
	on_dimensions_updated: "[
	]",
	
	on_type_updated: "fire_event('create')",

	on_being_removed: "[
		map(spawned_children, remove_object(value))
	]",

	on_search_focus: "
	if(widgets.search_entry != null and _search_label != null,
	[
		if(has_focus,
			remove_object(_search_label),

			has_focus = false and not regex_match(search_entry.text, '^.*[a-zA-Z0-9].*$'),
			if(_search_label not in level.chars, add_object(_search_label))
		),

		debug(['SEARCH', search_entry.has_focus])
	]
	where has_focus = not search_entry.has_focus
	where search_entry = text_editor_widget<- widgets.search_entry
	)
	",

	on_search_changed: "
	if(widgets.search_entry != null,
	[
	_show_clear_search_button(search_str != ''),
	if(not search_words,
	[
		set(_search_terms, null),
		set(_active_filters, search_filters),
		set_all_cards_visible(search_filters);
		refresh_view()
	],

	[
		set(_active_filters, []),
		set(_search_terms, map(filter(map(search_words, regex_replace(value, '[^0-9a-zA-Z]', '')), value), '\\b' + value) or null);
		if(new_visible_cards != _visible_cards,
			set(_visible_cards, new_visible_cards);
			refresh_view()
		)
	]
		
	  where new_visible_cards = [{
		name: 'Search Results',
		entries: _default_sort(filter(_all_cards, find(value.card.school_list, school_in_filter(value)) != null and type_in_filter(value.card) and value.card.matches_search(map(search_words, '.*\\b' + value + '.*')) and
		       find(search_filters, _matches_filter(value, context.value.card) = false) = null))
	  }]
	)
	]
	  where search_filters = [CardFilter] :: filter(map(filter(tokens, regex_match(value, '^.*[=:].*$')), _parse_filter(value)), value != null)
	  where search_words = filter(tokens, not regex_match(value, '^.*[=:].*$'))
	  where tokens = map(filter(split(search_str, ' '), value), lower(value))
	  where search_str = regex_replace((text_editor_widget<- widgets.search_entry).text, ': +', ':')
	)",
}
