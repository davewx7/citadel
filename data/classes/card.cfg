{
	bases: ['card_base'],
	constructor: "if(creature != null,
	              [
				  set(creature, creature + {name: name, school: school, hero: hero}),
				  set(creature_object, construct('creature', creature + {name: name, school: school})),
				  ])",

	properties: {
		type: { variable: true, default: 'creature', type: 'string' },
		initiative: { variable: true, default: 100, type: 'int' },
		rarity: { variable: true, default: 0, type: 'int' },

		//a unique id a card gets when drawn.
		draw_id: { variable: true, default: 0, type: 'int' },

		is_response: { variable: true, default: false },

		plays_on_stack: "true",

		creature: { variable: true, default: null, type: 'map|null' },
		creature_object: { variable: true, default: null, type: 'class creature|null' },
		rules: { variable: true, default: '' },

		hero: { variable: true, default: false },

		ai_score: "def(class game game, [[int]] targets) ->int 0",

		card_font: "'RobotoCondensed-Light'",

		rules_text_widgets: "def(int scale)
		 if(creature and creature_object,
		  (fold(
		   map(creature_short_abilities, [label_base + {
			 text: value + if(index = size(creature_short_abilities)-1, '\n', ''),
			 size: 12*scale,
			 tooltip: value + ': ' + lib.json.get_document_map('data/help-abilities.cfg')[value],
		   }]),
		   a + [label_base + {text: ', ', size: 12*scale}] + b, []) +

		   map(creature_long_abilities, [
		      map(range(value.cost), singleton('gui_widgets').resource_image(context.value.school[0], scale*14)),
		      singleton('gui_widgets').parse_markup_into_widgets(': ' + value.rules + '\n', 10*scale)
		   ])

			
		     where creature_short_abilities =
			   [a | a <- creature_object.abilities],
			       creature_long_abilities =
			   [a | a <- creature_object.activated_abilities]
				   ),
			 []
			) + singleton('gui_widgets').parse_markup_into_widgets(rules, 10*scale)


			where label_base = {
					type: 'label',
					color: 'black',
					size: 10*scale,
					font: card_font,
			   }
		",

		rules_text: "string <-
		   fold(filter(creature_short_abilities + [rules] + creature_long_abilities, value), a+'\n'+b, '')
		     where creature_short_abilities =
			   if(creature_object, [a | a <- creature_object.abilities], []),

			       creature_long_abilities =
			   if(creature_object,
				  [a.rules | a <- creature_object.activated_abilities], [])",

		targets_valid: "def(class game game, int nplayer, [[int]] targets, [[int]] existing=[])
		    if(possible = null, targets = [], if(possible = [] or targets = [], false,
				(targets[0] in possible) and
				targets_valid(game, nplayer, targets[1:], existing + [targets[0]])))
			where possible = possible_targets(game, nplayer, existing)
		",

		my_buildings_as_possible_targets: "def(class game game, int nplayer, [[int]] targets) ->[[int]]|null
		  if(targets = [], [creature.loc | creature <- game.creatures, creature.is_building, creature.controller = nplayer, creature.is_valid_target(game, nplayer, me)])",

		all_buildings_as_possible_targets: "def(class game game, int nplayer, [[int]] targets) ->[[int]]|null
		  if(targets = [], [creature.loc | creature <- game.creatures, creature.is_building, creature.is_valid_target(game, nplayer, me)])",

		enemy_buildings_as_possible_targets: "def(class game game, int nplayer, [[int]] targets) ->[[int]]|null
		  if(targets = [], [creature.loc | creature <- game.creatures, creature.is_building, creature.controller != nplayer, creature.is_valid_target(game, nplayer, me)])",
		  
		my_creatures_as_possible_targets: "def(class game game, int nplayer, [[int]] targets) ->[[int]]|null
		  if(targets = [], [creature.loc | creature <- game.creatures, not creature.is_building, creature.controller = nplayer, creature.is_valid_target(game, nplayer, me)])",

  		enemy_creatures_as_possible_targets: "def(class game game, int nplayer, [[int]] targets) ->[[int]]|null
		  if(targets = [], [creature.loc | creature <- game.creatures, not creature.is_building, creature.controller != nplayer, creature.is_valid_target(game, nplayer, me)])",

		all_creatures_as_possible_targets: "def(class game game, int nplayer, [[int]] targets) ->[[int]]|null
		  if(targets = [], [creature.loc | creature <- game.creatures, not creature.is_building, creature.is_valid_target(game, nplayer, me)])",

		all_tiles_as_possible_targets: "def(class game game, int nplayer, [[int]] targets) ->[[int]]|null
		  if(targets = [], game.all_locs)",

		possible_targets: "def(class game game, int nplayer, [[int]] targets) ->[[int]]|null
		   if(creature != null and targets = [],
				if(creature.is_construct,

					//buildings are built in a vacant village we own.
					[village | village <- keys(game.villages),
					           game.creature_at_loc(village) = null,
							   game.villages[village].owner = nplayer,
							   game.villages[village].level >= creature.level] +
					game.players[nplayer].summoning_locs(game, creature),

					game.players[nplayer].summoning_locs(game, creature)
                  ) )",
		do_summons: "def(class game game, class message.play_card info)
		   if(creature != null, summon_fn(construct('creature',
		     creature + {card_name: name, controller: game.current_player, loc: info.targets[0]}))
				  where summon_fn = if(creature.is_construct, game.summon_construct, game.summon_creature))
				  asserting size(info.targets) = 1",

		on_play_on_creature: "def(class game game, class creature target_creature) ->commands null",

		on_play: "def(class game game, class message.play_card info) ->commands
		 if(type = 'spell',
		   if(size(info.targets) = 1,
		    if(target_creature,
			  on_play_on_creature(game, target_creature))
			     where target_creature = game.creature_at_loc(info.targets[0])),
		    do_summons(game, info))",
		record_animation: "def(game, info, stack_id)
		if(true or type = 'spell', add(game.animation_hints, [
			{
				type: 'play_card',
				card_type: name,
				player: game.current_player,
				targets: info.targets,
			} + if(plays_on_stack, {stack_id: stack_id}, {})
		]))",

		runes: { default: [], type: "[map]" }
	}
}
