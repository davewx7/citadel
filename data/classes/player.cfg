{
	constructor: "[
		set(me.creature_avatar, construct('creature', {
			name: 'Avatar',
			controller: me.player_index,
			summon_id: 1000000+me.player_index,
			life: 1,
			loc: [-1,-1],
		}))
	]",

	properties: {
		name: "'Player ' + (player_index+1)",
		player_index: { variable: true, default: 0 },
		deck: { variable: true, default: [], type: '[string]' },
		deck_submitted: { default: false, type: 'bool' },
		discard_pile: { variable: true, default: [], type: '[string]',
		                set: "[set(me._data, value), if(value = [], set(me.visible_discard_pile, []))]" },

		//subset of cards in the discard pile that are visible.
		visible_discard_pile: { variable: true, default: [], type: '[string]' },

		creature_avatar: { variable: true, default: null, type: 'class creature' },

		next_draw_id: { variable: true, default: 1 },

		//hand can be set as actual card objects, or as strings, which
		//will result in card objects being built.
		hand: { variable: true, default: [], type: '[class card]',
		        set_type: '[class card|string]', set: "[
		  add(me.next_draw_id, size(value)),
		  set(me._data, map(value, if(is_string(value),
		   construct('card', (map<- (doc[value] asserting doc[value] | value) where doc = lib.json.get_document_map('data/cards.cfg')) + {draw_id: next_draw_id + index}), value)))
		] asserting value != null"
		},

		life: { variable: true, default: 3 },

		hand_size: { variable: true, default: 5 },

		begin_turn: "def(class game game) set(me.resources, count(game.villages, value.owner = player_index))",
		end_turn: "def(class game game, [int]|null keep_cards) [
		    bind_command(discard_cards, filter(range(size(hand)), value not in keep)),
			bind_command(draw_cards, game, hand_size - size(keep))
		] where keep = keep_cards or []",

		no_cards_to_draw: "size(deck) + size(discard_pile) = 0",

		guarantee_deck_size: "def(class game game, int ncards) ->class util.deck_state
			if(size(deck) >= ncards,
				construct('util.deck_state', {
					deck: deck,
					discard_pile: discard_pile,
				}),
				construct('util.deck_state', {
					deck: deck + shuffle(discard_pile),
					discard_pile: [],
				})
			)
		",

		draw_cards: "def(class game game, int ncards) if(num_cards > 0,
		[
		  if(num_cards > size(me.deck),
		  [
			  add(me.hand, deck + new_deck[:nfrom_discard]),
			  set(me.deck, new_deck[nfrom_discard:]),
			  set(me.discard_pile, []),
		  ] where new_deck = shuffle(discard_pile)
		    where nfrom_discard = num_cards - size(deck),
		  [
			add(me.hand, deck[:num_cards]),
			set(me.deck, deck[num_cards:])
		  ]),
		

		  add(game.animation_hints, [construct('animation.draw_cards_hint', {type: 'draw_cards', player: player_index, ncards: ncards})])
		]) where num_cards = min(ncards, size(deck) + size(discard_pile))",
		
		discard_cards: "def([int] card_indexes) ->commands
		[
		  map(card_indexes, add(me.discard_pile, [hand[value].name])),
		  set(me.hand, filter(me.hand, not (index in card_indexes))),
		  add(me.resources, size(card_indexes))
		]",

		discard_visible: "def(string card) ->commands
		[
			add(me.discard_pile, [card]),
			add(me.visible_discard_pile, [card]),
		]",

		add_static_level_up: "def(int school, int levels=1) ->commands [
			add_static_effect(
			    construct('static_effect', {
					apply_fn:  (def(class player p) add(p.resource_level[school], levels)) asserting school is int,
					revert_fn: (def(class player p) add(p.resource_level[school], -levels)) asserting school is int,
				}))
		] asserting school is int //looking for strict mode bug
		",

		remove_static_effects: "def() [
			map(me.static_effects, value.revert_fn(me)),
			set(me.static_effects, [])
		]",

		add_static_effect: "def(class static_effect effect) ->commands [
			effect.apply_fn(me),
			add(me.static_effects, [effect]),
		]",

		apply_static_effect: "def(function(class player) ->commands apply, function(class player) ->commands revert) ->commands [
			add_static_effect(construct('static_effect', {apply_fn: apply, revert_fn: revert}))
		]",

		static_effects: { default: [], type: '[class static_effect]' },

		level_up: "overload(
		  def([int] schools) ->commands map(schools, level_up(value)),
		  def(int school) ->commands bind_command(level_up_internal, school)
		)",

		level_up_internal: "def(int school) ->commands
		if(school != 0,
		  if(xp_level[school]+1 >= xp_needed[school],
			[
				add(me.resource_level[school], 1),
				add(me.xp_needed[school], 1),
				set(me.xp_level[school], 0),
			],
			[
				add(me.xp_level[school], 1)
			])
		  ) asserting school is int //looking for strict mode bug
		  ",

		xp_level: { default: '@eval {1:0,2:0,3:0,4:0,5:0}', type: '{int -> int}' },
		xp_needed: { default: '@eval {1:1,2:1,3:1,4:1,5:1}', type: '{int -> int}' },
		resource_level: { default: '@eval {1:0,2:0,3:0,4:0,5:0}', type: '{int -> int}' },
		resources: { variable: true, default: 0, type: 'int' },

		calculate_cost: "def(class card_base card) ->int
		  actual_cost(card.school, card.cost, card.loyalty_cost)",

		actual_cost: "def([int] resource_types, int cost, int loyalty_cost) ->int
		    cost + fold(map(resource_types, max(0, loyalty_cost - resource_level[value])), a+b)
			asserting is_list(resource_types), is_int(cost), is_int(loyalty_cost) | [resource_types, cost, loyalty_cost]",

		can_afford: "def([int] resource_types, int cost, int loyalty_cost)
		    resources >= actual_cost(resource_types, cost, loyalty_cost)
			  asserting is_list(resource_types), is_int(cost), is_int(loyalty_cost)",

		spend: "def([int] resource_types, int cost, int loyalty_cost)
		  add(me.resources, -actual_cost(resource_types, cost, loyalty_cost))",

		summoning_loc_in_row: "def(class game game, int row, int nmove=0) -> Loc
		  if(creature = null or creature.controller != player_index or
		     (not creature.summoned),
			 [row, column],
			 summoning_loc_in_row(game, row, nmove+1))
		  where creature = game.creature_at_loc([row,column])
		  where column = if(player_index = 0, nmove, (game.columns-1)-nmove)",

		construct_loc_in_row: "def(class game game, int row, int nmove=0) ->Loc
		  if(creature = null or creature.controller != player_index or
		     (not creature.summoned),
			 [row, column],
			 construct_loc_in_row(game, row, nmove+1))
		  where creature = game.construct_at_loc([row,column])
		  where column = if(player_index = 0, nmove, (game.columns-1)-nmove)",

		summoning_locs: "def(class game game, class creature target) ->[Loc]
		  fold([creature.allows_summoning(game, target) |
		        creature <- game.permanents, creature.controller = player_index],
				a+b) +
		  filter(map(range(game.rows), if(target.is_construct, construct_loc_in_row(game, value), summoning_loc_in_row(game, value))),
		    if(target.is_construct, game.construct_at_loc(value),
					                game.creature_at_loc(value)) = null)",

		has_possible_response: "def(class game game)
		  //do we have a response card we can play?
		  find(hand, value.is_response and suggest_discards(actual_cost(value.school, value.cost, value.loyalty_cost), [index])) != null or

		  //do we have a response ability we can play?
		  find(game.creatures,
		       value.controller = player_index and
		       find(value.activated_abilities,
			        value.is_response and can_afford(value.school, value.cost, value.loyalty_cost)) != null) != null
		",

		//suggest which cards to discard so we can play the given card
		suggest_discards: "def(int cost, [int] exclude=[]) -> [int]|null
		  if(need <= 0, [], if(need > size(available), null,
		   map(
		     sort(available,
			     actual_cost(a.school, a.cost, a.loyalty_cost) >
			     actual_cost(b.school, b.cost, b.loyalty_cost))[:need],
				index(hand, value))))
			where available = filter(hand, (not value.hero) and
			                               (not (index in exclude)))
		    where need = cost - resources",
	},

	test: [
		{ command: "set(vars.player, construct('player', { hand: [] }))" },
		{ command: "add(vars.player.resources, 5)",
		  assert: "vars.player.resources = 5" },
		{ assert: "vars.player.can_afford([1], 3, 2)" },
		{ assert: "not vars.player.can_afford([1], 3, 3)" },

		{ command: "vars.player.spend([1], 1, 2)",
		  assert: "vars.player.resources = 2",
		  message: "vars.player.resources" },

		{ assert: "not vars.player.can_afford([1], 1, 2)" },

		{ command: "vars.player.level_up(1)",
		  assert: "vars.player.can_afford([1], 1, 2)" }
	]
}
