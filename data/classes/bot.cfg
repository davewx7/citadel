{
	properties: {
		session_id: { variable: true, default: 0 },

		score_summons: "def(class game game, class card card, [int] loc)
		 (
		 	//score for there being an unowned glyph with no other creature
			//claiming it.
			if(nearest_unowned_glyph != null,
			   if(find(game.creatures,
					   value.loc[0] = loc[0] and
					   value.loc[1] >= nearest_unowned_glyph[1]) = null,
					   nearest_unowned_glyph[1]*10, 0), 0)
		 )
			  where nearest_glyph = choose(filter(keys(game.villages), value[0] = loc[0]), value[1])
			  where nearest_unowned_glyph = choose(filter(keys(game.villages), value[0] = loc[0] and game.villages[value].owner != game.current_player), value[1])
		",

		score_spell: "def(class game game, class card card, [[int]] targets) card.ai_score(game, targets)",

		score_play: "def(class game game, class card card, [[int]] targets) if(card.creature and size(targets) = 1, score_summons(game, card, targets[0]), score_spell(game, card, targets))",

		calculate_card_play: "def(class game game, class card card)
		  if(targets = [], null,
			if(targets = null, {card: card, targets: [], score: score_play(game, card, [])},
			  {
				card: card,
				targets: [best_target],
				score: score_play(game, card, [best_target]),
			  }
			  where best_target = choose(targets, score_play(game, card, [value]))
			))
		  where targets = card.possible_targets(game, game.nplayer, [])
		",

		get_best_play: "def(class game game)
		 if(plays,
		 if(is_list(best_combo) and size(best_combo) >= 1,
			plays[best_combo[0]] + {discards: filter(map(player.hand, if(value in best_combo, null, index)), value != null)}, null)
		  where best_combo = choose(combinations, fold(map(value, plays[value].score), a+b))
		  where player = game.players[game.nplayer]
		  where combinations = playable_combinations(game, plays)
		 )
		  where plays = calculate_plays(game)",

		calculate_plays: "def(class game game) fold(map(playable_cards(game), if(info, {(value): info}, null) where info = calculate_card_play(game, value)), a+b)",

		playable_combinations: "def(class game game, map plays_map, list play=[], int existing_cost=0)
		   map(candidates, play + [value]) + fold(map(candidates, playable_combinations(game, plays_map, play + [value], existing_cost + player.calculate_cost(value))), a+b)
		   where candidates = filter(player.hand[starting_index:],
		    (not (value in play)) and
		    (player.resources + size(player.hand) - (size(play)+1+existing_cost)) >= player.calculate_cost(value) and
			plays_map[value] != null and
			value.possible_targets(game, game.nplayer, []) != [])
		   where starting_index = if(play = [], 0, index(player.hand, play[size(play)-1])+1)
		   where player = game.players[game.nplayer]
		",

		playable_cards: "def(class game game)
		  filter(cards_to_consider(game, player),
		   player.resources + (size(player.hand)-1) >=
		   player.actual_cost(value.school, value.cost, value.loyalty_cost) and
		   (value.is_response or (not game.in_response_phase)) and
		   value.possible_targets(game, game.nplayer, []) != [])
		        where player = game.players[game.nplayer]",

		cards_to_consider: "def(class game game, class player player) ->[class card] player.hand",

		//utilities
		lane_has_neutral_towers: "def(game, nlane) find(game.creatures, value.loc[0] = nlane and value.controller = -1) != null",

		lane_has_neutral_glyphs: "def(game, nlane) find(map(filter(game.villages, key[0] = nlane), value), value.owner = -1)",

		lane_has_enemy_glyphs: "def(game, nlane) find(map(filter(game.villages, key[0] = nlane), value), value.owner != -1 and value.owner != game.nplayer)",

		lane_has_my_glyphs: "def(game, nlane) find(map(filter(game.villages, key[0] = nlane), value), value.owner = game.nplayer)",

		lane_empty: "def(game, nlane) find(game.creatures, value.loc[0] = nlane) = null",

		handle_message: "def(map message, object bot) [
		  debug('XX bot get message ' + message.state_id),
		  if(message.type = 'game' and (message.state.players[message.state.nplayer].deck = [] asserting message.state.players | message),
			[
			debug('BOT SUBMIT DECK: ' + deck),
			//submit our deck to the server.
			add(bot.script, [{
				session_id: session_id,
				send: {
					type: 'submit_deck',
					deck: deck,
				}
			}])
			],

			if(message.type = 'game' and message.state.nplayer = message.state.current_player,
				handle_game_message(message, bot),

				  add(bot.script, [{
					session_id: session_id,
					send: {
						type: 'request_updates'
					}
				  }])
			))
		]",

		handle_game_message: "def(map message, object bot)
		    if(summons and summons.score > 0,
				  send_moves(message, bot,
					[
						{
							type: 'discard',
							indexes: discard_indexes
						},
						
						{
							type: 'play_card',
							index: final_index asserting final_index >= 0 | [final_index, hand_index, discard_indexes, size(player.hand)],
							player_index: message.state.nplayer,
							targets: summons.targets,
						} where final_index = hand_index - count(discard_indexes, value < hand_index)
					]
				where discard_indexes = (summons.discards asserting not (hand_index in summons.discards))
				where hand_index = (index(player.hand, summons.card) asserting find(player.hand, summons.card) | summons)
				  ),
				  end_turn(message, bot))
				where summons = get_best_play(message.state)
				where player = message.state.players[message.state.nplayer],
		",

		end_turn: "def(map message, object bot) send_moves(message, bot, [{type: 'end_turn', keep: []}])",

		send_moves: "def(map message, object bot, [map] moves) [
				  debug('XX send moves: ' + moves),
				  add(bot.script, [{
					session_id: session_id,
					send: {
						type: 'moves',
						state_id: message.state_id,
						moves: moves
					}
				  }])
		]",

		deck: "get_document('data/ai-deck.cfg')"
	},
}
