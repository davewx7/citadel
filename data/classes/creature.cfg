{
properties: {
	summon_id: { variable: true, default: 0, type: "int" }, //unique within a game.
	name: { variable: true, type: "string" },
	school: { variable: true, default: [0], set: "set(me._data, if(is_int(value), [value], value))", set_type: "int|[int]", type: "[int]" },

	rules: { variable: true, default: '', type: "string" }, // copy of rules from card_type

	token: { type: 'bool', default: false },

	settings: "map <- {}",  //any custom settings peculiar to the instance.

	ai_value: "def(class game game) ->int if(base_card, (int<- base_card.cost) + (int<- base_card.loyalty_cost)/2, 0)",

	animation_hints: { variable: true, default: [], type: "[map]" },
	animation_hint_id: { variable: true, default: 1, type: "int" },

	add_animation_hint: "def(map hint) ->commands [add(me.animation_hints, [hint + {hint_id: animation_hint_id}]), add(me.animation_hint_id, 1)]",

	death_animation_hint: { variable: true, type: "string|null" },
	attack_hint: { variable: true, initialize: "construct('animation.attacks')", type: "class animation.attacks" },

	can_enter_endzone: { variable: true, default: true, type: "bool" },

	overlays: { variable: true, default: [], type: "[map]" },

	summoning_time: { variable: true, default: 2, get: "if(is_building, _data, 0)", type: "int" },
	summoning_counters: { variable: true, default: 0, type: "int" },
	force_summon: "set(me.summoning_counters, me.summoning_time)",

	increment_summoning: "add(me.summoning_counters, 1)",
	summoned: "summoning_counters >= summoning_time",

	is_building: "false",
	is_construct: "false",

	//the base card that this creature came from.
	card_name: { variable: true, default: null, type: 'string|null' },

	base_card: "map|null <- lib.json.get_document_map(q(data/cards.cfg))[card_name]",

	hero: { variable: true, default: false, type: "bool" },

	tags: { variable: true, default: [], type: "[string]" },

	//Status effects -- terrain doesn't get status effects.
	status_effects: { variable: true, get: "if(is_terrain, [], _data)", default: [], type: '[string]' },

	is_terrain: "'Terrain' in tags",

	exhaust_on_summon: "def(class game game) ->commands if(not 'Haste' in abilities, me.set_exhausted())",
	set_exhausted: "def() ->commands if(not ('Exhausted' in status_effects),
	             add(me.status_effects, ['Exhausted']))",

	refresh: "def() ->commands if(n >= 0, set(me.status_effects, status_effects[0:n] + status_effects[n+1:])) where n = index(status_effects, 'Exhausted')",

	is_exhausted: "'Exhausted' in status_effects",

	// List of strings containing keyworded abilities -- such as
	// 'Flying', First Strike', etc.
	abilities: { variable: true, default: [],
	             set: "set(me._data,
				        map(value, if(is_map(value), construct('activated_ability', value), value)))",
	  type: "[string]",
	  set_type: "[string]"},

	// List of activated abilities of type class activated_ability
	activated_abilities: {
		set: "set(me._data,
		        map(value, if(is_map(value), construct('activated_ability', value), value)))",
		type: "[class activated_ability]",
		set_type: "[map|class activated_ability]",
		default: [],
	},

	// List of triggered abilities of type class triggered_ability
	triggered_abilities: {
	  get: "if(summoned, _data, [])",
	  set: "set(me._data,
				        map(value, if(is_map(value), construct('triggered_ability', value), value)))",
	  type: "[class triggered_ability]",
	  set_type: "[map|class triggered_ability]",
	  default: [],
	  },

	sprite_sheet: { variable: true, default: null, type: "null|string" },
	image_num: { variable: true, default: 0 },

	range: { variable: true, default: 1, type: "int" },
	attack: { variable: true, default: 0, get: "if(summoned, me._data, 0)" },
	life: { variable: true, default: 1, get: "if(summoned, _data, min(_data, summoning_counters+1))" },
	move: { variable: true, default: 0, get: "if(fortification, 0, _data)" },
	spaces_moved_this_turn: { variable: true, default: 0 },
	initiative: { variable: true, default: 1 },

	resistance: { variable: true, default: 0, get: "if(summoned, _data, 0)" },

	resistance_against: "def(class game game, class creature attacker, int damage) ->int me.resistance",

	level: { variable: true, default: 0 },

	energy: { variable: true, default: 0 },

	reached_endzone: { variable: true, default: false },

	is_valid_target: "def(class game game, int nplayer, class card|class creature|class activated_ability obj) ->bool
	    not (nplayer != controller and has_cover(game))",

	has_cover: "def(class game game) ->bool ('Cover' in abilities)",

	handle_summoning: "def(class game game) ->commands [
		add_animation_hint({
			type: 'summoned',
		}),
		me.fire_event('on_summoned', [game])
	]",

	on_summoned: "def(class game game) ->commands null",

	on_attacked: "def(class game game, class creature attacker, int damage) ->commands null",

	on_deal_damage: "def(class game game, class creature target, int damage) ->commands
		map(me.abilities, switch(value, 'Life Drain', if(not target.is_building, add(me.wounds, -damage))))",

	inflict_combat_damage: "def(class game game, class creature attacker, int damage) ->commands
	if(damage_dealt > 0,
	    [add(me.wounds, damage_dealt),
		 me.fire_event('on_attacked', [game, attacker, damage]),
		 attacker.fire_event('on_deal_damage', [game, me, damage]),
		 if(damage_dealt_turn = game.turn,
		    add(me.damage_dealt_by, {
			  attacker.summon_id: damage_dealt + damage_dealt_by[attacker.summon_id]
			}),
			[set(me.damage_dealt_turn, game.turn),
			 set(me.damage_dealt_by, {attacker.summon_id: damage_dealt})]
		   )])
	  where damage_dealt = damage - me.resistance_against(game, attacker, damage)",

	hit_by_this_turn: "def(class game game) -> [int]
	  if(damage_dealt_turn = game.turn, map(damage_dealt_by, key), [])",

	on_kill: "def(class game game, class creature victim) ->commands null",
	on_another_creature_died: "def(class game game, class creature victim) ->commands null",

	on_die: "def(class game game) ->commands null",

	fire_events_on_death: "def(class game game) ->commands [
	   game.fire_creature_event('on_another_creature_died', [me]),
	   map(hit_by_this_turn(game), if(killer, killer.fire_event('on_kill', [game, me])) where killer = find(game.creatures, context.value = value.summon_id))
	   ]",

	on_reach_endzone: "def(class game game) ->commands [
		set(me.reached_endzone, true),
		add(player.life, if('Assassinate' in abilities, -player.life, -1))
		  where player = game.players[if(controller = 0, 1, 0)]
	]",

	wounds: { variable: true, set: "set(me._data, max(0, value))", default: 0 },

	destroyed: { set: "if(not indestructible, set(me._data, value))", type: 'bool', default: false },
	alive: "(life > wounds or is_construct or indestructible) and not destroyed",

	loc: { variable: true, default: [], type: '[int]' },
	is_on_board: "bool<- loc != []",

	tiles_from_start: "int<- if(loc, if(controller = 0, loc[1], 8 - loc[1]))",

	controller: { variable: true, default: -1 },

	stats_label_size: "15",
	stats_font: "'RobotoCondensed-Regular'",
	stats_alpha: "if(loc = null, 255, 96)",

	on_move_over_creature: "def(class game game, class creature creature) ->commands null",
	on_moved_over_by_creature: "def(class game game, class creature creature) ->commands null",

	on_move: "def(class game game) ->commands null",

	indestructible: "'Indestructible' in abilities",
	fortification: "'Fortification' in abilities",

	//formula which takes {creature, target, game} argument and applies the
	//static effect on the target.
	static_ability_effect: { variable: true, default: null, type: 'string|null' },

	//any general static effect.
	static_effect: "def(class game game) ->commands null",

	apply_static_abilities: "def(class game game) ->commands
	if(summoned, [
	static_effect(game),
	if(wounds < 0, set(me.wounds, 0)),
	if(me.static_ability_effect,
	    [map(game.creatures, commands<- eval_no_recover(me.static_ability_effect, {creature: me, target: value, game: game}))])])",

	apply_static_effect: "def(string attr, int delta) ->commands
	  if(summoned, [add(me[attr], delta), add(me.static_effects, [construct('creature.static_effect', {attr: attr, delta: delta})])])",
	apply_static_effect_while_summoning: "def(string attr, int delta) ->commands
	  if(not summoned, [add(me[attr], delta), add(me.static_effects, [construct('creature.static_effect', {attr: attr, delta: delta})])])",

	static_effects: { default: [], type: '[class creature.static_effect]', access: 'private' },
	static_abilities: { default: [], type: '[string]', access: 'private' },
	static_activated_abilities: { default: [], type: '[string]', access: 'private' },

	this_turn_effects: { default: [], type: '[map]', access: 'private' },
	this_turn_abilities: { default: [], type: '[string]', access: 'private' },
	this_turn_activated_abilities: { default: [], type: '[int]', access: 'private' },
	this_turn_triggered_abilities: { default: [], type: '[int]', access: 'private' },

	damage_dealt_turn: { default: -1, type: 'int', access: 'private' },
	damage_dealt_by: { default: {}, type: '{int -> int}', access: 'private' }, //maps creatures to amounts.

	ability_id: { default: 1, type: 'int', access: 'private' },

	remove_static_effects: "def() ->commands [
	   map(static_effects, add(me[value.attr], -value.delta)),
	   set(me.static_effects, []),
	   set(me.abilities, remove_abilities(abilities, static_abilities)),
	   set(me.static_abilities, [])]",

	add_ability_static_duration: "def(string ability) ->commands [
	  add(me.static_abilities, [ability]),
	  add(me.abilities, [ability])
	]",

	add_activated_ability_static_duration: "
	def(map activated_ability) ->commands
	[
	  add(me.ability_id, 1),
	  add(me.static_activated_abilities, [ability_id]),
	  add(me.activated_abilities, [activated_ability + {unique_id: ability_id}])
	]",

	apply_effect_until_end_of_turn: "
	  def(string attr, int delta) ->commands
	  [
	   add(me[attr], delta),
	   add(me.this_turn_effects, [{attr: attr, delta: delta}])
	  ]",

	add_ability_until_end_of_turn: "def(string ability) ->commands
	[
	  add(me.this_turn_abilities, [ability]),
	  add(me.abilities, [ability])
	]",

	add_activated_ability_until_end_of_turn: "def(map ability) ->commands
	[
	  add(me.ability_id, 1),
	  add(me.this_turn_activated_abilities, [ability_id]),
	  add(me.activated_abilities, [ability + {unique_id: ability_id}])
	]",

	add_triggered_ability_until_end_of_turn: "def(map ability) ->commands
	[
		add(me.ability_id, 1),
		add(me.this_turn_triggered_abilities, [ability_id]),
		add(me.triggered_abilities, [ability + {unique_id: ability_id}])
	]",

	fire_event: "def(string event_name, list args) ->commands
	 if(summoned, commands<- [
	  call(function<- query(me, event_name), args),
	  [ call(function<- query(ability, event_name), [me] + args) |
	    ability <- triggered_abilities, not is_string(ability)]
	]) asserting is_list(args) | [event_name, args]",

	begin_turn: "def(class game game) ->commands [
	  if(game.current_player = controller, [
			if('Regeneration' in abilities, add_animation_hint({
					type: 'regeneration'
				})),
	  		add(me.wounds, -count(abilities, value = 'Regeneration')
	  		               +count(status_effects, value = 'Poisoned')),
		]
	  ),
	  me.fire_event('on_begin_turn', [game])
	]",

	on_begin_turn: "def(class game game) ->commands null",

	remove_abilities: "def([string|int|class activated_ability|class triggered_ability] abilities, [string|int|class activated_ability|class triggered_ability] removal) ->[string|int|class activated_ability|class triggered_ability]
	 if(removal = [], abilities,
	  remove_abilities(remove_single_ability(abilities, removal[0]),
	                   removal[1:]))",

	remove_single_ability: "def([string|int|class activated_ability|class triggered_ability] abilities, string|int|class activated_ability|class triggered_ability item) ->[string|int|class activated_ability|class triggered_ability]
	  if(is_string(item), if(i = -1, abilities, abilities[0:i] + abilities[i+1:]) where i = index(abilities, item),
	   filter(abilities, value != ability)
	    where ability = find(abilities, value.unique_id = item))",
	
	on_end_turn: "def(class game game) ->commands null",

	end_turn: "def(class game game) ->commands [
	 me.fire_event('on_end_turn', [game]),
	 set(me.status_effects, if(ndx >= 0, me.status_effects[0:ndx]+me.status_effects[ndx+1:],me.status_effects)) where ndx = index(me.status_effects, 'Exhausted'),
	 map(this_turn_effects, add(me[value.attr], -value.delta)),
	 set(me.this_turn_effects, []),
	 set(me.abilities, remove_abilities(abilities, this_turn_abilities)),
	 set(me.activated_abilities, remove_abilities(activated_abilities, this_turn_activated_abilities)),
	 set(me.triggered_abilities, remove_abilities(triggered_abilities, this_turn_triggered_abilities)),
	 set(me.this_turn_abilities, [])
	]",

	//the number of spaces this creature wants to move, according to its
	//behavior. (Which includes stopping when in range of an enemy).
	desired_moves: "def(class game game, int movement) ->int
	 if(range <= 1 or ('Flying' in abilities), movement,
	   if(nmoves = null, movement, nmoves)
	 where nmoves = find(range(movement), find_target(game, direction_moving, (value+range)*direction_moving)))",

	do_move: "def(class game game) ->commands
	  if(move > 0, move_creature(game, move))",
	
	move_creature: "def(class game game, int nmoves) ->commands
	  do_move_internal(game, find_first_vacant(game, find_blocker(game, 1, desired_moves(game, moves)+1, direction) - 1), direction)
	   where direction = direction_moving*sign(nmoves)
	   where moves = abs(nmoves)
	",

	do_trample_move: "def(class game game) ->commands
	if(moves_left > 0,
	(
	  [
	  	do_move_internal(game, move_spaces),
	  	if(move_spaces <= 0, set(me.status_effects,
			 filter(me.status_effects, value != 'Trampling') +
			 ['Exhausted'])
		)
	  ]
	   where move_spaces = find_blocker(game, 1,
	                        desired_moves(game, moves_left)+1) - 1
	 ),

	   set(me.status_effects, filter(me.status_effects, value != 'Trampling'))

	  )
	  where moves_left = move - spaces_moved_this_turn",

	do_move_internal: "def(class game game, int move_spaces, int dir=0) ->commands
	[
	  set(me.spaces_moved_this_turn, move_spaces),
	  if(move_spaces = 0, null,
	  
	  if(game.creature_at_loc(target_loc) = null and (game.is_loc_on_board(target_loc) or game.is_loc_in_endzone(target_loc, controller) and can_enter_endzone),
		  [
		  map(range(1, move_spaces+1), [game.capture(
		    moveover_loc, if(is_marauder, -1, controller)),
			if(creature != null, [creature.fire_event('on_moved_over_by_creature', [game, me]), me.fire_event('on_move_over_creature', [game, creature])]) where creature = game.creature_at_loc([loc[0], loc[1] + value*direction])
			] where moveover_loc = [loc[0], loc[1] + value*direction]
			) where is_marauder = ('Marauder' in abilities),
		  set(me.loc, target_loc),
		  if('Charge' in abilities, apply_effect_until_end_of_turn('attack', move - move_spaces)),
		  ], do_move_internal(game, move_spaces-1, direction)
	  )
	  where target_loc = [loc[0], loc[1] + move_spaces*direction])
	  where direction = if(dir = 0, direction_moving, dir)
	]
      asserting loc",

	targets_attacking: "def(class game game) ->[class creature]
	[class creature]<-
	   filter(map(search_directions, find_target(game, value, value*range)), value != null and (range > 1 or (('Flying' in abilities) = ('Flying' in value.abilities))))
	  //we want to attack in both directions if we're neutral, otherwise
	  //attack in the direction we're going.
	  where search_directions = if(controller = -1, [-1,1], [direction_moving])",

	do_attack: "def(class game game) ->commands if(attack > 0, [
	  set(me.attack_hint, construct('animation.attacks', { turn: game.turn, attacks:
	      map(targets, construct('animation.attack_hint', { target: value, target_loc: value.loc, damage: attack}))})),
	  map(targets, value.inflict_combat_damage(game, me, attack)),
	  if(targets, add(me.status_effects,
	    if(('Trample' in abilities) and spaces_moved_this_turn < move,
		    ['Trampling'], ['Exhausted'])))
	] where targets = targets_attacking(game)
	)",
	

	find_target: "def(class game game, int moves_ahead, int max_moves) ->class creature|null
	  if(potential != null and potential.controller != me.controller and
	     (abs(moves_ahead) = 1 or potential.is_valid_target(game, me.controller, me)), potential, if(moves_ahead = max_moves, null, find_target(game, moves_ahead + sign(moves_ahead), max_moves)))
	  where potential = game.creature_at_loc([loc[0], loc[1] + moves_ahead])",

	//overridable to allow evasion.
	can_evade: "def(class game game, class creature target) ->bool false",

	find_blocker: "def(class game game, int moves_ahead, int max_moves, int dir=0) ->int
	   if(blocking_creature != null and
		  blocking_creature != me and
	      blocking_creature.controller != me.controller and
		  (not me.can_evade(game, blocking_creature)) and
		  ('Flying' in blocking_creature.abilities) = ('Flying' in me.abilities),
		  moves_ahead,
		  if(moves_ahead+1 < max_moves,
			 find_blocker(game, moves_ahead+1, max_moves), max_moves))
	   where blocking_creature = game.creature_at_loc([loc[0], loc[1] + moves_ahead*direction])
	   where direction = dir or direction_moving
	   ",

	find_first_vacant: "def(class game game, int moves_ahead, int dir=0) ->int
	  if(moves_ahead <= 0, 0,
	  if(game.creature_at_loc([loc[0],
			                  loc[1] + moves_ahead*direction]),
		    find_first_vacant(game, moves_ahead-1, direction),
			moves_ahead))
		where direction = dir or direction_moving",

	transform: "def(class game game, map|class creature new_type) ->commands [
	  set(game.creatures, filter(game.creatures, value.summon_id != me.summon_id) + [new_creature]),

	  set(new_creature.wounds, me.wounds),
	  set(new_creature.loc, me.loc),
	  set(new_creature.controller, me.controller),
	  set(new_creature.summon_id, me.summon_id),
	  set(new_creature.card_name, me.card_name),
	] where new_creature = if(is_map(new_type), construct('creature', new_type), new_type)",

	direction_moving: "if(controller = 1, -1, 1)",

	//has an enemy immediately in front
	is_engaged: "def(class game game) ->bool
	   enemy != null and enemy.controller != controller
	     where enemy = game.creature_at_loc(
		                      [loc[0], loc[1] + direction_moving])",

	//if this creature allows summoning in additional tiles.
	allows_summoning: "def(class game game, class creature target) ->[[int]] []",

	gui_status_grid: "
		if(status_effects = [], null,
			{
				type: 'grid',
				padding: [10,10],
				columns: 1,
				x: 10, y: 0,
				zorder: 2,
				children: map(status_effects,
				{
					type: 'image',
					image: 'citadel-icons.png',
					area: [icon_num*10, 0, (icon_num+1)*10-1, 9]
					   where icon_num = switch(value,
					   'Exhausted', 5,
					   'Poisoned', 6,
					   5)
				})
			}
		)
	",
	
	gui_stats_grid: "def(int facing, int img_w, int img_h) ->map
 	{
		type: 'grid',
		id: 'gui_stats_grid',
		columns: 2,				
		column_alignments: 'centre',
		xy: [if(facing >= 0, -30, 60), (img_h-10*itm_count/2)/2],
		alpha: stats_alpha,
		children: [] +				

		if((not is_construct) and ((not is_building) or attack > 0),
		[
			{
				type: 'image',
				image: 'citadel-buildings.png',
				area: [117 + 10*attack,266,126 + 10*attack,275],
			},
			{
				type: 'image',
				image: 'citadel-icons.png',
				area: [40,0,49,9],
			},
		], []) +

		if((not is_construct) and range > 1, [
			{
				type: 'image',
				image: 'citadel-buildings.png',
				area: [117 + 10*range,266,126 + 10*range,275],
			},
			{
				type: 'image',
				image: 'citadel-icons.png',
				area: [30,0,39,9],
			},
		], []) +

		if((not is_construct) and resistance != 0, [
			{
				type: 'image',
				image: 'citadel-buildings.png',
				area: [117 + 10*abs(resistance),if(resistance < 0,286,266),126 + 10*abs(resistance),if(resistance < 0,295,275)],
			},
			{
				type: 'image',
				image: 'citadel-icons.png',
				area: if(resistance < 0, [10,0,19,9], [20,0,29,9]),
			},
		], []) +

		if((not is_construct) and (not loc), [
			{
				type: 'image',
				image: 'citadel-buildings.png',
				area: [117 + 10*life,266,126 + 10*life,275],
			},
			{
				type: 'image',
				image: 'citadel-icons.png',
				area: [0,0,9,9],
			},
		], []) +

		if((not is_construct) and ((not is_building) or move > 0),
		[
			{
				type: 'image',
				image: 'citadel-buildings.png',
				area: [117 + 10*move,266,126 + 10*move,275],
			},
			{
				type: 'image',
				image: 'citadel-icons.png',
				area: [70,0,79,9],
			},
		], []) +

		if(energy > 0,
		[
			{
				type: 'image',
				image: 'citadel-buildings.png',
				area: [117 + 10*energy,266,126 + 10*energy,275],
			},
			{
				type: 'image',
				image: 'citadel-icons.png',
				area: [60,0,69,9],
			},
		], []),
								
				
				/*+

		if(is_building or level > 0, [
			{
				type: 'label',
				color: 'black',
				text: '',
				size: 12,
				font: stats_font,
			},
			{
				type: 'image',
				image: 'citadel-buildings.png',
				area: [127 + 9*level,266,136 + 9*level,275],
			},
		], [])*/
		
	} where itm_count = if((not is_building) or attack > 0,2,0) + if(range > 1,2,0) + if(resistance != 0,2,0) + if((not is_building) or move > 0,2,0)/* + if(is_building or level > 0,2,0)*/
	"
},
	classes: {
		static_effect: {
			properties: {
				attr: { type: 'string' },
				delta: { type: 'int' },
			}
		}
	}
}
